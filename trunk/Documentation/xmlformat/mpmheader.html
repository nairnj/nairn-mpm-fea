<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

<head>
	<meta http-equiv="content-type" content="text/html;charset=ISO-8859-1">
	<title>MPMHeader</title>
	<link rel="stylesheet" type="text/css" href="../help.css">
</head>

<body>

<p class="links">
<a href="../index.html">Home</a> &rarr;
<a href="index.html#contents">MPM XML File Contents</a>
</p>

<h1>MPM Header</h1>

<p>
This section defines many MPM analysis parameters; it is required for NairnMPM and not allowed for NairnFEA. Some options have default values (specified below) and can be omitted if the default value is acceptable. Some parameters (also indicated below) are required.
</p>

<pre>
&lt;MPMHeader&gt;
    &lt;<a href="#matlptsperelement"><code>MatlPtsPerElement</code></a>&gt;4&lt;/MatlPtsPerElement&gt;
    &lt;<a href="#mpmmethod"><code>MPMMethod</code></a>&gt;2&lt;/MPMMethod&gt;
    &lt;<a href="#gimp"><code>GIMP</code></a> type='uGIMP'/&gt;
    &lt;<a href="#timestep"><code>TimeStep</code></a> units='ms'&gt;1&lt;/TimeStep&gt;
    &lt;<a href="#timefactor"><code>TimeFactor</code></a>&gt;0.1&lt;/TimeFactor&gt;
    &lt;<a href="#maxtime"><code>MaxTime</code></a> units='ms'&gt;120&lt;/MaxTime&gt;
    &lt;<a href="#atime"><code>ArchiveTime</code></a> units='ms'&gt;2&lt;/ArchiveTime&gt;
    &lt;<a href="#fatime"><code>FirstArchiveTime</code></a> units='ms'&gt;100&lt;/FirstArchiveTime&gt;
    &lt;<a href="#aroot"><code>ArchiveRoot</code></a> unique='0'&gt;results/fullDCB/root.&lt;/ArchiveRoot&gt;
    &lt;<a href="#mpmarchive"><code>MPMArchiveOrder</code></a>&gt;mYYYYNYYYNYYNNNNNY&lt;/MPMArchiveOrder&gt;
    &lt;<a href="#crackarchive"><code>CrackArchiveOrder</code></a>&gt;mYYYN&lt;/CrackArchiveOrder&gt;
    &lt;<a href="#globalarchivetime"><code>GlobalArchiveTime</code></a> units='ms'&gt;1&lt;/GlobalArchiveTime&gt;
    &lt;<a href="#globalarchive"><code>GlobalArchive</code></a> type='sxx' mat='1'/&gt;
    &lt;<a href="#feedbackdamping"><code>FeedbackDamping</code></a> target='3'&gt;10&lt;/FeedbackDamping&gt;
    &lt;<a href="#damping"><code>Damping</code></a>&gt;25&lt;/Damping&gt;
    &lt;<a href="#stressfreetemp"><code>StressFreeTemp</code></a>&gt;25&lt;/StressFreeTemp&gt;
    &lt;<a href="#diffusion"><code>Diffusion</code></a> reference='1'/&gt;
    &lt;<a href="#mmmode"><code>MultiMaterialMode</code></a> Vmin='0.0' Dcheck='1'&gt;
        &lt;<a href="#mmfriction"><code>Friction</code></a>&gt;0.3&lt;/Friction&gt;
        &lt;<a href="#mmcontactposition"><code>ContactPosition</code></a>&gt;0.8&lt;/ContactPosition&gt;
    &lt;/MultiMaterialMode&gt;
    &lt;<a href="#cracks"><code>Cracks</code></a>&gt;
        &lt;<a href="#propagate"><code>Propagate</code></a> criterion='1' direction='0' traction='0'/&gt;
        &lt;<a href="#altpropagate"><code>AltPropagate</code></a> criterion='7' direction='4' traction='0'/&gt;
        &lt;<a href="#propagatelength"><code>PropagateLength</code></a>&gt;2.5&lt;/PropagateLength&gt;
        &lt;<a href="#jcontour"><code>JContour</code></a> type='1' size=&quot;2&quot; terms=&quot;1&quot;/&gt;
        &lt;<a href="#friction"><code>Friction</code></a>&gt;0.3&lt;/Friction&gt;
        &lt;<a href="#moveplane"><code>MovePlane</code></a> type='avg' prevent='no'/&gt;
        &lt;<a href="#contactposition"><code>ContactPosition</code></a>&gt;0.8&lt;/ContactPosition&gt;
    &lt;/Cracks&gt;
    &lt;<a href="#leave"><code>LeaveLimit</code></a>&gt;10000&lt;/LeaveLimit&gt;
    &lt;<a href="#kmax"><code>DefGradTerms</code></a>&gt;2&lt;/DefGradTerms&gt;
&lt;/MPMHeader&gt;
</pre>

<p>where</p>

<dl>
  <dt><a name="matlptsperelement"></a>&lt;MatlPtsPerElement&gt;</dt>
  <dd>Number of material points in each element. The supported options are 1, 4, 9, 16, and 25 per cell in 2D or axisymmetric and 1, 8, or 27 per cell in 3D (<b>Default values: 4 for 2D or axisymmetric and 8 for 3D</b>).</dd>

  <dt><a name="mpmmethod"></a>&lt;MPMMethod&gt;</dt>
  <dd>MPM algorithm used. The options, entered by number code, are:
  <ul class="lev2args">
  <li>0: update strain first (most efficient)</li>
  <li>2: update both (most accurate)</li>
  <li>3: modified update strain last (acceptable)</li>
  </ul>
  An option 1 used to be for an update strain last approach from the original MPM paper by <a href="references.html#SCS1994">Sulsky <i>et al.</i> (1994)</a>, but it was found to be unreliable and has been removed from NairnMPM. It was replaced by option 3, which is described by <a href="references.html#SZS1995">Sulsky <i>et al.</i> (1995)</a>. Because option 3 requires a second extrapolation, it is less efficient. The alternative option 0 avoids that extrapolation and works well (see <a href="references.html#Bardenhagen2002">Bardenhagen (2002)</a>). Option 2 combines options 0 and 3 and can be considered as a midpoint rule algorithm; it is seen to be more accurate in one example in <a href="references.html#Nairn2003">Nairn (2003)</a>. Because of this potentail improved accuracy, <b>option 2 is the default option</b> in NairnMPM. If efficiency is crucial (<i>e.g.</i>, for very large calculations), the recommended option is 0.</dd>
  
<dt><a name="gimp"></a>&lt;GIMP type='uGIMP'/&gt;</dt>
<dd>This command defines the method used to calculate shape functions and their gradients. The <code>type</code> options are:
  <ul class="lev2args">
  <li><code>Dirac</code> (or <code>Classic</code>): classic shape functions</li>
  <li><code>uGIMP</code> (or <code>GIMP</code>): uniform GIMP based</li>
  <li><code>lCPDI</code> (or <code>CPDI</code>): convected particle domain integration with linear shape functions</li>
  <li><code>qCPDI</code>: convected particle domain integration with quadratic shape functions</li>
  </ul>
<code>Dirac</code> is the classic MPM method and does not work very well when material points cross element boundaries. All other methods are approximations to a method known as GIMP or the generalized interpolation material point method (<a href="references.html#Bardenhagen2004">Bardenhagen and Kober (2004)</a>). Using one of these methods is probably essential when material points cross element boundaries. The GIMP development can be reduced to integrals of grid shape functions over the particle's deformed domain by using a weighting function that is 1 in that domain and zero elsewhere. Evaluating these integrals is difficult (in 2D and 3D); the above GIMP methods (<code>uGIMP</code>, <code>lCPDI</code>, and <code>qCPDI</code>) differ only in their method to find the integrals:
<ul class="lev2args">
  <li><code>uGIMP</code>: assumes the particle domain is fixed at its original size and just translates with the particle (see <a href="references.html#Bardenhagen2004">Bardenhagen and Kober (2004)</a>)</li>
  <li><code>lCPDI</code>: assumes the particle domain deforms into a parallelogram (2D) or a parallelepiped (3D) (as defined by its current deformation gradient) and then expands GIMP integrands using linear isoparametric shape functions with nodes at the corners of the parallelogram (2D) or parallelepiped (3D) (as developed by <a href="references.html#Brannon2011">Sadeghirad, Brannon, and Burghardt (2011)</a> although they described it differently than the simpler view given here, and they called it just <code>CPDI</code>).</li>
  <li><code>qCPDI</code>: same as <code>lCPDI</code> except expands GIMP integrands using using quadratic shape functions with 9 nodes at corners, edge midpoints, and domain center of the parallelogram (currently planar 2D only). This unpublished method was developed for trials in this code. It is slower than <code>CPDI</code> and does not appear to have much advantage.</li>
</ul>
&nbsp;&nbsp;&nbsp;&nbsp;Because <code>lCPDI</code> and <code>qCPDI</code> account for deformed particle domain (approximately), they perform much better at very high strains. In problems where <code>Dirac</code> or <code>uGIMP</code> have numerical fracture caused by particles being separated by more than one element, <code>lCPDI</code> and <code>qCPDI</code> may continue to work.<br>

&nbsp;&nbsp;&nbsp;&nbsp;The use of any GIMP method requires a regular grid that is generated using the <a href="definemesh.html"><code>Grid</code></a> command.<br>

&nbsp;&nbsp;&nbsp;&nbsp;When using GIMP, a particle is considered to have left the grid if it moves into any element on the edge of the analysis. Thus, the use of GIMP will cause the <a href="definemesh.html"><code>Grid</code></a> command to automatically add an extra boundary of elements. Note that the edge restriction does not apply to particles with <a href="definematl.html#rigid">rigid materials</a>; such particles can be in edge elements.<br>

&nbsp;&nbsp;&nbsp;&nbsp;If this command is omitted, the <b>default value is <code>Dirac</code></b>.  If the command is used but has no <code>type</code> attribute, the <code>uGIMP</code> method is used.</dd>
  
  <dt><a name="timestep"></a>&lt;TimeStep&gt;</dt>
  <dd>Time for each MPM step. If needed, the time step will automatically be made shorter to insure convergence. A <a href="#units"><code>units</code> attribute</a> specifies the time units. (<b>Default value: 1 sec</b>)</dd>
  
  <dt><a name="timefactor"></a>&lt;TimeFactor&gt;</dt>
  <dd>Safety factor used in checking for allowed time step. It is the fraction of a cell
  that a particle can move when moving at the wave speed of the material over a single time step. Must be less than 1 for convergence and less the 0.5 is recommended. (<b>Default value: 0.5</b>)</dd>

  <dt><a name="maxtime"></a>&lt;MaxTime&gt;</dt>
  <dd>Time when the analysis will stop. A <a href="#units"><code>units</code> attribute</a> specifies the time units. (<b>Default value: 1 sec</b>)</dd>

  <dt><a name="atime"></a>&lt;ArchiveTime&gt;</dt>
  <dd>Time between archiving particle results to files. A <a href="#units"><code>units</code> attribute</a> specifies the time units. (<b>Default value: 1 sec</b>)</dd>
  
  <dt><a name="fatime"></a>&lt;FirstArchiveTime&gt;</dt>
  <dd>This tag lets you set the time at which archiving will start. The data at the start of the calculation will always be archived, but then no archiving will be done until this time is reached. After this time is reached, the archiving will proceed at intervals specified by <a href="#atime"><code>&lt;ArchiveTime&gt;</code></a>. A <a href="#units"><code>units</code> attribute</a> specifies the time units. (<b>Default value: 0 sec</b>)</dd>
  
  <dt><a name="aroot"></a>&lt;ArchiveRoot&gt;</dt>
  <dd>Unix path name to archive files. It is relative to the input file or current working directory (depending on the -w option when code is started). Gives
  the start of file name. An extension for the step number will be appended as data is archived.
  For example, the archive root could be '<code>results/root.</code>' and the archived data will be
  in a series of files beginning with '<code>results/root.1</code>'. Nested folders are allowed and
  will automatically be created if needed. (Required)<br>
  &nbsp;&nbsp;&nbsp;&nbsp;The optional <code>unique</code> attribute (if = 1) will force the creation of a new folder by inserting a folder '1', '2', <i>etc</i>., as needed to get a new folder, within the last folder specified by the relative path in <code>ArchiveRoot</code>.</dd>
  
  <dt><a name="mpmarchive"></a>&lt;MPMArchiveOrder&gt;</dt>
  <dd>A series of 'Y' and'N' flags to determine which particle data will be saved in the archived files. For details on the format of the archived files see <a href="../outformat/index.html">NairnMPM Archive Files.</a> The options are:
  <ul class="lev2args">
  <li>Byte 1: Byte order of archived files ('m' for Macintosh order or 'i' for Intel chip order). This parameter is ignored on input but must be supplied for alignment.</li>
  <li>Byte 2: Default particle properties (particle mass, position, material information, and thickness). This byte must always by 'Y'.</li>
  <li>Byte 3: Particle velocity</li>
  <li>Byte 4: Particle stress</li>
  <li>Byte 5: Particle strain (which is elastic strain for plasticity materials)</li>
  <li>Byte 6: Particle plastic strain</li>
  <li>Byte 7: Should always be 'N'. Present to support reading old versions of archive files.</li>
  <li>Byte 8: Particle external work</li>
  <li>Byte 9: Particle temperature</li>
  <li>Byte 10: Particle plastic energy</li>
  <li>Byte 11: Should always be 'N'. Present to support reading old versions of archive files.</li>
  <li>Byte 12: Particle total shear strain components (du/dy and dv/dx)</li>
  <li>Byte 13: Particle strain energy</li>
  <li>Byte 14: Setting 'Y' or 'N' refers to particle history variable 1. See <a href="../outformat/index.html#sec1">archive file information</a> for other settings to store more history variables - these history variables are only meaningful for some <a href="definematl.html">material types</a></li>
  <li>Byte 15: Particle concentration and concentration gradients - only meaningful when doing <a href="#diffusion">diffusion</a> calculations.</li>
  <li>Byte 16: Approximate particle thermal energy (&rho; C<sub>p</sub> &Delta;T<sup>2</sup>/(2 T<sub>0</sub>) where T<sub>0</sub> is the <a href="#stressfreetemp">stress free temperature</a>) - only meaningful when doing <a href="thermal.html">conduction</a> calculations and only accurate when the temperature changes are small.</li>
  <li>Byte 17: Number of times this particle crossed an element boundary since the last archive time.</li>
  <li>Byte 18: Rotational strain; this strain must be archived for visualization tools to be able to plot &quot;transformed&quot; points (<i>i.e.</i>, the stretch and shear plotted points to match the material point deformation state).</li>
  </ul>
  
  (<b>Default value: mYNN... or iYNN...</b> (<i>i.e.</i> one Y and the rest N) depending on computer and reverse byte settings)</dd>

  <dt><a name="crackarchive"></a>&lt;CrackArchiveOrder&gt;</dt>
  <dd>A series of 'Y' and'N' flags to determine which crack data will be saved in the archived files. For details on the format of the archived files see <a href="../outformat/index.html">NairnMPM Archive Files.</a> The options are:
  <ul class="lev2args">
  <li>Byte 1: Byte order of archived files ('m' for Macintosh order or 'i' for Intel chip order). This parameter is ignored on input but must be supplied for alignment.</li>
  <li>Byte 2: Default crack particle properties (location, surface positions). This byte must always by 'Y'.</li>
  <li>Byte 3: J Integral at designated crack tips (see <a href="cracks.html">defining cracks</a>).</li>
  <li>Byte 4: Stress intensity factors at designated crack tips (see <a href="cracks.html">defining cracks</a>).</li>
  <li>Byte 5: Dynamic energy balancing results (in research, not meant for general use).</li>
  </ul>
  
  (<b>Default value: mYNNNN or iYNNNN</b> depending on computer and reverse byte settings)</dd>

  <dt><a name="globalarchivetime"></a>&lt;GlobalArchiveTime&gt;</dt>
  <dd>You can optionally save global results (such as average stress or total energies) to a tab delimited file of global results. This file will appear in the same directory as other archive files (see <a href="#aroot">ArchiveRoot</a> command) but have the extension <code>.global</code>. This parameter determines how often global results are written to the global file. An optional <a href="#units"><code>units</code> attribute</a> can specify the time units. The time interval can differ from the <a href="#atime">ArchiveTime</a> setting. If this parameter is omitted, no global results will be saved. The results that are saved are determined by one or more <code>GlobalArchive</code> commands listed next. (<b>Default value: no global archiving</b>).</dd> 
  
  <dt><a name="globalarchive"></a>&lt;GlobalArchive type='sxx' mat='0'/&gt;</dt>
  <dd>Use one or more of these commands to determine what data are calculated and written to the global results file (see <code>GlobalArchiveTime</code> command above). If <code>mat</code> is omitted or equal to zero, the calculation will include all non-rigid material points. If <code>mat</code> is non-zero, the calculation will include only particles with that material number (<code>mat</code>, see <a href="definematl.html">Defining Materials</a> and it may be a rigid material; numbers can be replaced by names using a <code>matname</code> attribute
as explained <a href="definematl.html#usemats">here</a>). The global results file will be tab-delimited file with time (in msec) in column one and each requested quantity in subsequent columns. The global quantities (or <code>types</code>) that can be archived are:
<ul class="lev2args">
	<li><code>sxx</code>, <code>syy</code>, <code>szz</code>, <code>sxy</code>, <code>sxz</code>, or <code>syz</code> - average element of the stress tensor in MPa</li>
	<li><code>sRR</code>, <code>sZZ</code>, <code>sTT</code>, or <code>sRZ</code> - average element of the axisymmetric stress tensor in MPa (synonyms for <code>sxx</code>, <code>syy</code>, <code>szz</code>, and <code>sxy</code>)</li>
	<li><code>exx</code>, <code>eyy</code>, <code>ezz</code>, <code>exy</code>, <code>exz</code>, or <code>eyz</code> - average element of the total strain tensor in %, which is elastic+plastic strain for for material that separate them and total strain for others.</li>
	<li><code>eRR</code>, <code>eZZ</code>, <code>eTT</code>, or <code>eRZ</code> - average element of the axisymmetric total strain tensor % (synonyms for <code>exx</code>, <code>eyy</code>, <code>ezz</code>, and <code>exy</code>)</li>
	<li><code>exxe</code>, <code>eyye</code>, <code>ezze</code>, <code>exye</code>, <code>exze</code>, or <code>eyze</code> - average element of the elastic strain tensor in %. For hyperelastic materials, this elastic strain is actually the total strain.</li>
	<li><code>eRRe</code>, <code>eZZe</code>, <code>eTTe</code>, or <code>eRZe</code> - average element of the axisymmetric elastic strain tensor % (synonyms for <code>exxe</code>, <code>eyye</code>, <code>ezze</code>, and <code>exye</code>)</li>
	<li><code>exxp</code>, <code>eyyp</code>, <code>ezzp</code>, <code>exyp</code>, <code>exzp</code>, or <code>eyzp</code> - average element of the plastic strain tensor in %. For hyperelastic materials, this strain is 100 &times; left Cauchy Green tensor.</li>
	<li><code>eRRp</code>, <code>eZZp</code>, <code>eTTp</code>, or <code>eRZp</code> - average element of the axisymmetric plastic strain tensor % (synonyms for <code>exxe</code>, <code>eyye</code>, <code>ezze</code>, and <code>exye</code>)</li>
	<li><code>velx</code>, <code>vely</code>, or <code>velz</code> - average component of velocity in mm/sec</li>
	<li><code>velR</code> or <code>velZ</code> - average component of axisymmetric velocity in mm/sec (synonyms for <code>velx</code> or <code>vely</code>)</li>
	<li><code>dispx</code>, <code>dispy</code>, or <code>dispz</code> - average component of displacement in mm</li>
	<li><code>dispR</code> or <code>dispZ</code> - average component of axisymmetric displacement in mm (synonyms for <code>dispx</code> or <code>dispy</code>)</li>
	<li><code>contactx</code>, <code>contacty</code>, or <code>contactz</code> - component of the total contact force on the grid in N for <a href="#mmmode"><code>MultiMaterialMode</code></a> simulations when they include <a href="definematl.html#rigid">rigid materials</a> that have <code>SetDirection</code>=8. It is a sum of all contact forces for the rigid material on the object in Newtons. If the simulation has activated the <a href="custom.html#VTKArchive">VTKArchive custom task</a>, that task must archive <code>contactforce</code> or else these global archive results might get invalid zero forces.</li>
	<li><code>contactR</code> or <code>contactZ</code> - component of the total contact force per radian on the axisymmetric grid in N (synonyms for <code>contactx</code> or <code>contacty</code>)</li>
	<li><code>temp</code> - The average temperature</li>
	<li><code>concentration</code> - the weight fraction concentration (for <a href="#diffusion">diffusion calculations</a>)</li>
	<li><code>Strain Energy</code> - total strain energy in J from total work</li>
	<li><code>Heat Energy</code> - total heat energy in J</li>
	<li><code>Kinetic Energy</code> - total kinetic energy in J</li>
	<li><code>Energy</code> - sum of total strain and kinetic energies in J</li>
	<li><code>Interface Energy</code> - total energy associated with cracks having imperfect interfaces in J. You need to add total &quot;Strain Energy&quot; and this total &quot;Interface Energy&quot; to get the total strain energy in an elastic material with imperfect interfaces.</li>
	<li><code>External Work</code> - total external work in J</li>
	<li><code>Potential Energy</code> - total energy minus total external work in J</li>
	<li><code>Plastic Energy</code> - total plastic energy in J</li>
	<li><code>Thermal Energy</code> - total approximate thermal energy in J (from &rho; C<sub>p</sub> &Delta;T<sup>2</sup>/(2 T<sub>0</sub>) which assumes small temperature changes and T<sub>0</sub> is the <a href="#stressfreetemp">stress free temperature</a>)</li>
	<li><code>alpha</code> - the evolving damping factor, &alpha;, in <a href="#feedbackdamping">feedback damping</a> (in 1/sec).</li>
	<li><code>Step number</code> - the current MPM step number</li>
	<li><code>Elapsed time</code> - elapsed clock time for the current calculation (in secs)</li>
	<li><code>CPU time</code> - total CPU time for the current calculation (in secs)</li>
</ul>
Note that forces and energies are all per radian in axisymmetric calculations. Any invalid quantity will be ignored. (<b>Default value: no global archiving</b>)
</dd>

  <dt><a name="feedbackdamping"></a>&lt;FeedbackDamping target='5' max='20000'&gt;</dt>
  <dd>Adds numerical damping on the update of particle velocity using a Nose-Hoover thermostat (<a href="references.html#Ayton2002">Ayton <i>et al.</i> (2002)</a>). With feedback damping on, the particle velocity update is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v<sub>p</sub>(t+dt) = v<sub>p</sub>(t) + (a<sub>p</sub><sup>*</sup>
- &alpha;v<sub>p</sub><sup>*</sup>)dt<br>
where &alpha; is a global damping coefficient that is initialized to zero and evolves by<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(d&alpha;/dt) = (2K/m<sub>tot</sub>) [ ( &Sigma; (1/2) m<sub>p</sub>|v<sub>p</sub><sup>*</sup>|<sup>2</sup> ) - T<sub>k</sub> ]<br>
where K is the parameter entered in the <code>FeedbackDamping</code> command (with units of 1/mm<sup>2</sup>), m<sub>tot</sub> is total mass, and T<sub>k</sub> is the target kinetic energy (entered in the <code>target</code> attribute as a <a href="function.html">user-defined function</a> of time that evaulates to total kinetic energy in &mu;J (per radian in axisymmetric calculations); the <b>default target is 0</b>). The (2/m<sub>tot</sub>) is an arbitrary scaling used to make K similar to a different feedback damping method used earlier vin NairnMPM and an attempt to make K less dependent on problem size.
<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sometimes the damping coefficient, &alpha;, losses control and evolves to a value that overdamps the problem. To prevent overdampoing, you can specify a maximum &alpha; (in units of 1/sec as explained in <a href="#damping"><code>Damping</code> command</a>) by using the <code>max</code> attribute, although usually overdamping is a symptom of a poorly designed simulation with too much kinetic energy. (<b>Default max: &lt;=0 or no limit</b>).
<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Nose-Hoover thermostat works in molecular calculations by tying kinetic energy to temperature. Here the thermostat ties kinetic energy to an expected kinetic energy after vibrations are damped out. When boundary conditions are constant, the target kinetic energy should be zero and feedback damping will help the problem converge to the static solution. For non-constant boundary conditions, you need to estimate the &quot;static&quot; (<i>i.e.</i>, very slow loading) kinetic energy to have this thermostat work correctly. The damping also depends on K; selecting a good value requires trial and error.
</dd>
  
  <dt><a name="damping"></a>&lt;Damping function='2000*sign(1.0-t)'&gt;</dt>
  
  <dd>Grid damping constant. You can either specify a value in the text of this command or specify a <a href="function.html">user-defined function</a> of time in the <code>function</code> attribute. The specified value or the function result should be in units of 1/sec. This type of damping is applied directly to the nodes. It is less sophisticated than <a href="#feedbackdamping">FeedbackDamping Command</a>, but sometimes it can give better results, especially if the feedback damping loses control and starts to over damp. Higher values give more damping. (<b>Default value: 0</b>)<br>
  
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;With grid damping on, the nodal velocity update becomes<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v<sub>i</sub>(t+dt) = v<sub>i</sub>(t) + (a<sub>i</sub><sup>*</sup>
- kv<sub>i</sub><sup>*</sup>)dt<br>
where  a<sub>i</sub><sup>*</sup> = (f<sub>i</sub><sup>int</sup> + f<sub>i</sub><sup>ext</sup>)/m<sub>i</sub> is nodal acceleration without damping, v<sub>i</sub><sup>*</sup> = p<sub>i</sub>/m<sub>i</sub> in nodal velocity, m<sub>i</sub> is nodal mass, and k is the parameter entered in the <code>Damping</code> command (or obtained from the <code>function</code> result).<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The amount of damping to approach static results without over damping depends on the problem being damping. Under static conditions (no longer applying forces or moving particles), the total kinetic energy on the grid will decay with a exponential time constant on the order of &tau; &asymp; 1/(2k). The amount of damping should scale with wave speed of the materials or vibration times in certain problems. For a given problem, the damping will therefore scale with &radic;(E/&rho;). One set of tension tests on an isotropic material with E = 2300 MPa and &rho; = 1 g/cm<sup>3</sup> looked good with k = 5000 sec<sup>-1</sup> or &tau; &asymp; 0.1 msec.<br>
  
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It would easy to revise the code to allow a damping function of nodal position as well, which would permit simulations were different parts of the grid damped differently.
</dd>
  
<dt><a name="stressfreetemp"></a>&lt;StressFreeTemp&gt;</dt>
<dd>This tags allows you to specify a stress free or reference temperature, which will be the starting temperature for all particles. This temperature can be changed by setting the particle's intial temperature, by applying a <a href="thermal.html">thermal ramp</a> to gradually change all particle temperatures, or by calculations involving <a href="thermal.html">thermal conductivity</a> along with heat sources or thermal boundary conditions. Note that setting initial particle temperature different than the stress free temperature will cause strains to immediate evolve toward the changed state. The net effect will be an instantaneous &quot;impact&quot; of temperature change that might cause undesirable dynamic effects. A <a href="thermal.html">thermal ramp</a> can apply an initial temperature change more slowly to softening this &quot;impact&quot; effect.<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For most materials, thermal effects only depend on relative changes in temperature and those changes lead to stresses and strains by thermal expansion. For some materials (<i>e.g.</i>, <a href="definematl.html#idealgas">Ideal Gas</a> materials), the constitutive law uses this temperature and assumes it is an absolute temperature in degrees K. For other materials, only relative temperature changes matter (wth degree size in C or K degrees), but it is safest to always enter this temperature in K. The <b>default value is 0</b>, which means this value must be set when using materials that require an absolute reference temperature.
</dd>

<dt><a name="diffusion"></a>&lt;Diffusion reference='1'/&gt;</dt>
  <dd>Activates diffusion calculations. Without this element in the MPM Header, no diffusion calculations will be done. When diffusion is activated, you can set <a href=".html">material diffusion and expansion constants</a>, initial <a href="definempm.html#sec2">particle concentrations</a>, and impose <a href="dispbc.html#conc">concentration</a> or <a href="mpmloads.html#flux">flux</a> boundary conditions. All calculations are done in terms of a concentration potential from 0 to 1 where 1 is the saturation concentration of a material type. When concentration and concentration gradients are archived, however, they are converted to actual concentration in weight fraction using the <a href="definematl.html">material's saturation concentration</a> setting. The <code>reference</code> attrbute is used to set a reference concentration potential (between 0 and 1) that corresponds to zero strain. (<b>Default values: diffusion off and <code>reference</code> = 0</b>)
  <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concencentration changes are coupled to stress and strains through concentration expansion coefficients <a href="definematl.html">defined for the materials</a>. By default, all moisture expansion coefficients are zero which decouples diffusion and strains. By entering non-zero values, the coupling will occur. Note that setting initial particle concentrations different than the reference concentration will cause strains to immediately evolve toward the changed state. The net effect will be an instantaneous &quot;impact&quot; of concentration change that might cause undesirable dynamic effects.</dd>
  
<dt><a name="mmmode"></a>&lt;MultiMaterialMode Vmin='0.0' Dcheck='0' Normals='0' RigidBias='100'&gt;</dt>

<dd>This command enables <a href="references.html#Bardenhagen2001">multi-material MPM</a> where each material has a separate velocity field. During calculations, nodes that interact with more than one material use multimaterial contact methods to adjust the momenta. The contact can implement frictional contact, stick contact, or <a href="references.html#NairnII2013">imperfect interface laws</a>. The attributes and subordinate commands define the properties of the multimaterial mode calculations.
  <br>
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multimaterial contact is detected by various criteria. The first check is on the total undeformed volume from all materials extrapolated to the nodal point. If this volume is less than the <code>Vmin</code> attribute, the node is assumed to <i>not</i> be in contact and the materials therefore move in their separate velocity fields. The <b>default Vmin is 0.0</b>, which means the volume check is skipped. Values around 1.0 give good results when all contact is within a continuum having no voids. If the simulation has voids or edges and contact occurs near those boundaries, however, a setting of 1.0 will skip those contact situations. Although this is physically not correct, it is difficult to find normals at corners and can therefore be better to skip them. You should proceed with caution, however, for simulations that has contact near edges. (<font color="red">Warning:</font> if this value is non-zero in 2D calculations, you must set the <a href="definemesh.html"><code>thickness</code> attribute in the <code>&lt;Grid&gt</code>; command</a> as well.)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If the volume check is passed (or skipped), the second check is on the relative normal direction velocities of the materials. If they are moving apart, they are assumed to not be in contact. If they are moving together, the next check is performed. This check is never skipped.<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The last check is a calculation of absolute displacement between the surfaces of the two materials. This check can be turned on or off by setting <code>Dcheck</code> attribute to 1 or 0 (the <b>default Dcheck is 0 or disabled</b>, although enabled is usually recommended). When it is enabled, the displacement calculations can be done using particle displacements (best when surfaces were originally in contact and relative motion is small during the calculation) or positions (best when surfaces come into contact during the simulation or the relative motion is large). See <a href="#mmcontactposition"><code>ContactPosition</code></a> command for details.<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Both the above contact detection and the subequent contact calculations depend on the surface normals. The <code>Normals</code> and <code>RigidBias</code> attributes activate several options for finding the normals.

<dl>

<dt>Normals='0' RigidBias='1'</dt>
<dd>These settings mean to take the normal from the material that has the largest magnitude of volume gradient at the node. When the simulation has stationary <a href="definematl.html#rigid">rigid materials (with <code>SetDirection</code>=8)</a>, those particles might provide more accurate normals. To make use of this accuracy, you can use the <code>RigidBias</code> attribute; it means to take the normal from the volume gradient of the rigid material unless the volume gradient of the non-rigid material is the specified bias factor larger than the rigid material gradient. The larger the <code>RigidBias</code> factor, the more like the gradient will come from the rigid material.
</dd>

<dt>Normals='1'</dt>
<dd>This setting means to take the normal from the material that has the largest volume at the node. The <code>RigidBias</code> factor is ignored.</dd>

<dt>Normals='2' RigidBias='1'</dt>
<dd>These settings mean to use a volume-weighted average of volume gradients for the two materials in contact. If more than two non-rigid materials are present, it averages the material of interest with the average gradient of all other materials combined. If one of the other materials is a rigid materials, it averages with only the rigid material's volume gradient. The <code>RigidBias</code> (see <code>Normals='0'</code> section) is used and compares this average volume gradient to the volume gradient from the rigid material alone; it uses the rigid one alone unless the average one is the specified bias factor larger then the rigid one.</dd>

<dt>Normals='3'</dt>
<dd>This setting means to calculate the normal from each material's own volume gradient. In contact or interface calculations, the calculations are done separately for the two sides for the surface. If the normals are not equal and opposite, this method (unlike the other three) will not conserve momentum. It is the method originally proposed in MPM contact methods (<i>e.g.</i>, <a href="references.html#Bardenhagen2001">Bardenhagen, <i>et al.</i></a>), before the importance of the normal was better appreciated.</dd>

</dl>

The <b>default values are <code>Normals=2</code> and <code>RigidBias=1</code></b>, which means to use the volume-weighted average volume gradient and to have no bias for the rigid materials. These methods for finding normals are described in <a href="references.html#Lemiale2010">Lemiale <i>et al.</i> (2010)</a> and in <a href="references.html#NairnII2013">Nairn (2013)</a>.<br><br>

The possible subordinate commands within the <code>MultiMaterialMode</code> section are:

<dl>

<dt><a name="mmfriction"></a>&lt;Friction&gt; </dt>
  <dd>This command sets friction for contact between all pairs of materials or sets them to be an <a href="references.html#NairnII2013">imperfect interface</a>. The properties are set as explained for the <a href="#friction"><code>friction</code></a> command in the <a href="#cracks">cracks</a> section except that a setting less than -10 means to assume materials are always in contact and therefore to revert to single material mode. This setting is intended for testing code to verify results are identical to the same calculations done in non-multimaterial mode.<br>
  &nbsp;&nbsp;&nbsp;&nbsp;The <code>MultiMaterialMode</code> friction setting in the header defines the default law for multimaterial contact. You can have separate laws for each material pair by using <a href="definematl.html#friction"><code>Friction</code> commands</a> within material definitions.
  </dd>
  
<dt><a name="mmcontactposition"></a>&lt;ContactPosition&gt;0.8&lt;/ContactPosition&gt;</dt>

<dd>If this command is absent, surface displacements are calculated from particle displacements. If this command is present, surface displacements are calculated from particle positions and this command sets the relative normal separation that is considered to be in contact. See <a href="#contactposition"><code>ContactPosition</code></a> command in the <a href="#cracks">cracks</a> section for details. <b>Default is to be absent</b> or to use surface displacements.<br>
</dd>
  
</dl>

The recommended multimaterial modes settings are <code>Vmin</code>=0.0, <code>Dcheck</code>=1, <code>Normals</code>=2, and <code>ContactPosition</code>=0.8 (see <a href="references.html#Lemiale2010">Lemiale, <i>et al.</i>, 2010</a>). The defaults for <code>Vmin</code> and <code>Normals</code> match these recommendations. The <code>Dcheck</code>=1 and <code>ContactPosition</code>, however, have to explicitly be set. The final settings you select will be described in the &quot;Multimaterial Contact&quot; section of the output text file.
 
</dd>

<dt><a name="cracks"></a>&lt;Cracks&gt;</dt>
<dd>Defines some extra parameters used when the MPM analysis has <a href="cracks.html">explicit cracks</a> (which is an MPM feature first described in <a href="references.html#Nairn2003">Nairn (2003)</a>). The extra parameters are all contained within the <code>Cracks</code> tag.

<dl>

<dt><a name="propagate"></a>&lt;Propagate criterion='1' direction='0' traction='1'/&gt;</dt>
  <dd>Determines whether or not cracks propagate and the rule (or criterion) used to initiate crack growth. Two optional attributes determine the crack-growth direction and whether or not the new crack surface has a traction law. Crack growth can only occur at designated crack tips (see <a href="cracks.html">defining cracks</a>). The criterion is set in the <code>criterion</code> attribute and has options:
  
<ul class="lev2args">
<li value="0">0 (None): No crack propagation (<b>default value</b>).</li>

<li>1 (Max Energy Release): For crack growth based on stress intensity factors and a single critical stress intensity factor (K<sub>Ic</sub>). The propagation condition is based on the maximum energy release rate (also known as the maximum hoop stress criterion). The default propagation direction is in the direction of the maximum energy release rate (or the direction of maximum hoop stress).</li>

<li>2 (Steady State Crack Growth): For crack initiation when total energy release rate (J) reaches a critical value (specified by J<sub>Ic</sub>) or when the time reaches a specified time. Once the crack has initiated, the crack grows at a specified constant speed. It may be stopped at any predetermined maximum length. The default propagation direction is self-similar crack growth.</li>

<li>3 (Energy Balance): For crack growth by a dynamic energy balancing scheme. The research is described in <a href="references.html#Nairn2005">one paper</a>, but the method not yet meant for general use. The default propagation direction is self-similar propagation.</li>

<li>4 (Energy Density): For crack growth based on stress intensity factors and a single critical stress intensity factor (K<sub>Ic</sub>). The propagation condition is based on the minimum strain energy density. The default propagation direction is in the direction of minimum strain energy density.</li>

<li>5 (Elliptical): For crack growth based on stress intensity factors and two critical stress intensity factors (K<sub>Ic</sub> and K<sub>IIc</sub>). The default propagation direction is the direction of maximum energy release rate (see criterion 1 above). The criterion for crack growth is
(K<sub>I</sub>/K<sub>Ic</sub>)<sup>p</sup> + (K<sub>II</sub>/K<sub>IIc</sub>)<sup>q</sup>=1</li>

<li>6 (Max CTOD): For crack growth if the crack tip opening displacement at the crack tip exceeds &delta;<sub>Ic</sub> or &delta;<sub>IIc</sub> if one or both are specified. The default propagation direction is self-similar propagation.</li>

<li>7 (Critical ERR): For crack growth when energy release rate exceeds J<sub>Ic</sub>. The default propagation direction is self-similar propagation.
</li>

</ul>

<p>Each criterion above has a default method for determinaton of the crack propagation direction. The optional <code>direction</code> attribute can override the default method with one of the following methods:</p>

<ul class="lev2args">

<li value="0">0 (<b>default</b>): To use the default direction for the above criterion.</li>

<li>1 (self similar): To grow in the direction of the crack tip crack segment.</li>

<li>2 (cod normal): To grow normal to a vector between the top and bottom surface at the crack tip.</li>

<li>3 (cod hoop): To estimate the direction of maximum energy release rate based on the normal and shear crack opening displacements. This direction is similar to <code>max energy release</code> criterion above, but can be used on any type of material.</li>

<li>4 (initial): To grow in the crack tip direction defined by the initial crack geometry.</li>

</ul>
By default, cracks propagate as new, traction-free crack surfaces. The traction attribute changes this behaviour such that newly created crack segments will be initialized with the specified traction law material. Enter by material number, and the material must be a traction law material. See <a href="references.html#Nairn2009">Nairn (2009)</a> for paper on using traction laws on new crack surfaces.
<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See <a href="definematl.html">information on materials</a> to set crack propagation properties such as K<sub>Ic</sub>, K<sub>IIc</sub>, K<sub>I</sub> exponent p, K<sub>II</sub> exponent q, J<sub>Ic</sub>, initiation time, crack speed, maximum crack length, <i>etc.</i>, and to create traction-law materials. Note that all criteria are based on materials with isotropic toughness properties (same toughness in all directions). The material may have anisotropic mechanical properties, but anisotropy in toughness is not yet modeled. See the <a href="#altpropagate">AltPropagate</a> command (described next) for one method to deal with anisotropic toughness properties.</dd>
  
<dt><a name="altpropagate"></a>&lt;AltPropagate criterion='7' direction='4' traction='1'/&gt;</dt>

<dd>This command lets you set a second propagation criterion to use in certain specific models that involve competing or anisotropic fracture modes. The parameters are identical to the <a href="#propagate">Propagate</a> command except the second criterion cannot be 2 or 3. When a second criterion is used, the following steps take place:

<ol>
  <li>At each time step, the first criterion is checked. If the situation is critical, the crack will propagate by the first criterion and the second criterion will subsequently be turned off for that crack tip.</li>
  <li>As long as the first criterion has not become critical, the second criterion will be checked. The crack will propagate by that criterion if it is critical.</li>
  <li>When propagation information is printed to the output file, it will include &quot;(alt)&quot; when propagating by the second criterion and will omit that wording once the primary criterion is activated.</li>
</ol>

This option was added to allow simulations of competing fracture modes such as crack growth along a weak interface <i>vs.</i> propagation away from the interface into the bulk material. For this problem, the first criterion is set to the bulk fracture properties and the second criterion is the interface fracture criterion. The later is usually set to be by self-similar crack growth or crack growth in the initial crack direction so it will be along the interface. In this scheme, the crack will propagate along the interface until turning into the bulk becomes critical. Once it turns into the bulk, the interface fracture mechanics is turned off.
<dd>
  
  
<dt><a name="propagatelength"></a>&lt;PropagateLength&gt;0.5&lt;/PropagateLength&gt;</dt>

<dd>When <a href="#propagate">propagation is activated</a>, the crack tip propagates whenever the current <a href="#propagate">fracture criterion</a> is reached. This command determines how far the crack propagates entered relative to cell dimensions. <b>The default setting is 0.5</b>, or half an element per propagation increment. This setting often works well, but during impact conditions, it may not be enough. If the crack growth is too low, the critical conditions will still be exceeded and may actually grow beyond acceptable limits for the current material (<i>e.g.</i>, <code>J</code> can greatly exceed <code>J<sub>c</sub></code>). Using a higher propagation length can help such problems. It moves the current crack tip out of the current stress concentration and it waits there for stress to build up again resulting in more stable crack growth. This setting should not be too high, however, because it will eventually cause artifacts and erratic crack growth. It should also not be so low as to numerically restrict crack speed. Since crack growth rate can reach wave speeds, the propagation length should never be lower than the <a href="#timefactor"><code>TimeFactor</code></a>. If propagation length is less than this value, it can never reach wave speed of the material, even if it propagates on every time step.
</dd>
  
<dt><a name="jcontour"></a>&lt;JContour type='1' size=&quot;2&quot; terms=&quot;1&quot;/&gt;</dt>
<dd>Determines the path used for <a href="references.html#Guo2004">J-Integral calculations</a>. The current code always draws a contour along grid lines of the mesh and all local grid lines must be parallel to x or y axes. In the future the <code>type</code> attribute may allow other types of contours. The <code>size</code> attribute determines size of the contour path. It is the number of elements from the nearest node to the crack tip to the path in all directions. The <code>terms</code> attribute must be 1 or 2 where 1 means contour integral only and 2 means an additional term that integrates over the area within the contour. The extra term is needed for true path independence of J calculations. The second terms of usually small when the <code>size</code> is small (&lt;3) and the loading rate is low, but it can be important (and even essential) if <code>size</code> gets large or the loading rate gets high. (<b>Default values: <code>type</code>=1, <code>size</code>=2, <code>terms</code>=1</b>).<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;See <a href="references.html#Guo2004">Guo and Nairn (2004)</a> and <a href="references.html#Bardenhagen2011">Bardenhagen <i>et al.</i> (2011)</a> for results using different J-integral contours and 1 or 2 terms.
</dd>
  
<dt><a name="friction"></a>&lt;Friction Dn='200' Dt='5'&gt;0.0&lt;/Friction&gt; </dt>
<dd>Default coefficient of friction for crack contact calculations. Enter the friction coefficient or enter zero for frictionless contact. Enter number less than -10 to ignore crack contact (which is unrealistic analysis when crack surfaces do contact), or enter a number between -1 and -9 to have crack contact by stick conditions. See <a href="cracks.html">crack definitions</a> for a method of having different contact laws on different cracks. (<b>Default value: 0</b>)<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The friction setting also allows the contact to be modeled as an imperfect interface (in which case it is not really a crack, but an imperfect bond line within the specimen). To specify an imperfect interface, set the friction to a value greater than 10 and then use attributes <code>Dn</code>, <code>Dnc</code>, <code>Dnt</code>, and <code>Dt</code> to set interfacial stiffnesses (in MPa/mm). <code>Dn</code> and <code>Dt</code> determine the interfacial normal and tangential traction as this stiffness times the displacement discontinuity in the normal and tangential directions. For the normal direction <code>Dnc</code> and <code>Dnt</code> let you specific different stiffnesses in compression (surfaces in contact) or tension (surfaces sparated). In theory, an infinite stiffness leads to zero discontinuity or a perfect interface, but high stiffnesses make dynamic MPM unstable. Instead, you can get a perfect interface in any direction by setting the stiffness to -1. When imperfect interfaces are present, you can track their energy using the <a href="#globalarchive">Interface Energy archiving option</a>. The use of cracks to model imperfect interfaces is described in <a href="references.html#Nairn2007b">Nairn (2007b)</a> and the implementation of imperfect interface in multimaterial mode is decribed in <a href="references.html#NairnII2013">Nairn (2013)</a>.
</dd>
  
<dt><a name="moveplane"></a>&lt;MovePlane type='avg' prevent='yes'&gt;</dt>
<dd>These settings determine how the crack planes move and whether or not cracks surface are allowed to pass through crack planes. The default settings of  <code>type</code> = '<code>avg</code>' and <code>prevent</code> = '<code>yes</code>' means the two crack surfaces move in their separate velocity fields, the crack plane is defined as the average of the two surfaces, and the crack surfaces are prevented from passing through crack planes. The alternative setting for <code>type</code> is '<code>cm</code>' which means the crack plane moves in the center of mass velocity field. The crack surfaces still move in their separate velocity fields. To allow crack surfaces to pass through the crack plane, change <code>prevent</code> to '<code>no</code>'.<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Both <code>type</code> methods are valid and usually give equivalent results. For some problems, one method or the other is better. Thus, if crack movement seems to cause a problem, try repeating the analysis with the alternate <code>MovePlane</code> setting for <code>type</code>. The '<code>avg</code>' method is slightly faster because it does not need to calculate nodal center of mass velocities. (Default value: 'avg').<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similarly, both <code>prevent</code> settings are equivalent for well behaved cracks (because surfaces tend to not pass through crack planes). If a simulation has problems tracking surfaces, you can try setting <code>prevent</code> to '<code>no</code>' to see how it changes. The '<code>no</code>' setting is faster because it does not need to check crack surfaces on each time step. (Default value: 'yes')
</dd>
  
<dt><a name="contactposition"></a>&lt;ContactPosition&gt;0.8&lt;/ContactPosition&gt;</dt>
<dd>The option for determining contact across a crack surface or between materials is to look for the normal crack opening displacement (COD) to be less than zero. The question is how is the normal COD calculated? The default method is to calculate it from particle displacements. This approach is accurate provided the two surfaces of the crack are in contact at the start of the analysis (<i>e.g.</i>, the crack's starting COD is zero). Since internal cracks normally start in contact, this default displacement approach is the best one for madeling crack contact and composite material contact.<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cracks in CRAMP (or <a href="#mmmode">multimaerial mode</a>) can also model surfaces including <a href="cracks.html">imperfect interfaces</a>. If the modeled surfaces only come into contact during the calculations (<i>i.e.</i>, one or both sides of the crack or material surface have no particles at the start of the calculation), the displacement approach can be inaccurate. An approximate correction is to use this command and specify a critical position to define contact. Use of this command converts contact detection to be based on extrapolated particle positions rather than displacements. The critical position given by the command is the difference between the extrapolated particle positions (as fraction of cell dimensions) for the top and bottom surfaces that should be considered as contact. When using 4 particles per cell in 2D calculations, the critical position difference would seem to be 0.5, but MPM does not precisely locate edge positions. Calculations with shape functions suggest the critical position should be about 0.8. This value of 0.8 is probably good for 4 particles (2D) or 8 particles (3D) per cell. It should be changed with one particle per cell (probably &gt; 1.0, but has not been studied). See <a href="references.html#Lemiale2010">Lemiale <i>et al.</i> (2010)</a> for some discussion on contact position methods.<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only a single contact position can be entered and it applies to cracks regardless of their orientation. To work in problems with cracks in different orientations, the problem should use a regular mesh of square elements. The position method is allowed for non-square meshes, but the result will be contact conditions that depend on crack orientation.
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When cracks or <a href="#mmmode">multimaterial mode</a> are modeling <a href="cracks.html">imperfect interfaces</a>, this setting affects the calculation of normal COD for finding the normal interfacial force. The most accurate imperfect interface calculations will be for cracks (or materials) initially in contact with COD found using displacements (<i>i.e.</i>, no <code>&lt;ContactPosition&gt;</code> command). For imperfect interfaces that are not initially in contact, the contact position method can be used, although accuracy should be checked.<br>
  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When a simulation has cracks and also uses <a href="#mmmode">multimaterial mode</a>, only one method is allowed for calculating displacements and that method applies to both material and crack contact. The default method is to use particle displacements. If either the <a href="#mmmode"><code>MultiMaterialMode</code></a> section or the <a href="#cracks"><code>Cracks</code></a> section has a <code>ContactPosition</code> command, then both contact algorithms will find displacements from particle positions. Displacements are used in multimaterial mode for verifying contact (only when <code>Dcheck</code> attribute of the <a href="#mmmode"><code>MultiMaterialMode</code></a> command is 1) and for implementing imperfect interface tractions. If neither of these features of multimaterial mode are being used, the <code>ContactPosition</code> setting has no effect on that mode and will apply only to crack-surface contact.
</dd>

</dl>
</dd>
  
<dt><a name="leave"></a>&lt;LeaveLimit&gt;10000&lt;/LeaveLimit&gt;</dt>
<dd>This command is used to force particles that try to leave the grid back into the grid. The leave limit is the number of analysis steps that will allow a particle to leave the grid. Once the limit is reached the analysis will stop. The default value is 1, which means the first particle to leave the grid will stop the analysis. Normally you should keep particles in the grid by using appropriate boundary conditions on the edges of the grid. In some calculations, numerical artifacts may cause particles to jump beyond the boundary conditions. This command can help those analyses to continue without stopping, but if many particles have to be returned to the grid, the results might be suspect.</dd>

<dt><a name="kmax"></a>&lt;DefGradTerms&gt;2&lt;/DefGradTerms&gt;</dt>
<dd>During strain updating of hyperelastic materials, the incremental deformation gradient is best found from exp(&Delta;t grad v), which is found by Taylor series expansion of the exponential function. This command sets the number of terms to use in that expansion. More terms should be more accurate, but will take longer. Using a single term can be shown to have errors when rotation is involved. Those errors are greatly reduced by using the 2 terms (which is the default). It is harder to verify any benefit of using 3 or more terms.</dd>
</dl>

<a name="units"></a><h2>Units Attribute in Some Commands</h2>

<p>Many commands allow an optional <code>units</code> attribute to specify the units of a numeric value. If no units attribute is used, the value will have default units depending on physical quantity associated with the command. The possible units settings and their default values are:
</p>

<dl>
<dt>Time</dt>
<dd>The possible options are 'sec', 'ms', 'msec', or 'microsec'. The default units are seconds.</dd>

<dt>Length</dt>
<dd>The possible options are 'mm', 'm', 'cm', 'microns', 'in', or 'ft'. The default units are millimeters.</dd>

<dt>Velocity</dt>
<dd>The possible options are 'mm/sec', 'mm/msec', 'm/sec', 'cm/sec', 'in/sec', or 'ft/sec'. The default units are millimeters per second.</dd>

<dt>Mass</dt>

<dd>The possible options are 'g', 'kg', 'mg', 'lbs',  or 'oz'. The default units are grams.</dd>
</dl>

<p>The <code>units</code> attribute is only allowed in commands the specify it is allowed.</p>

<p class="links">
<a href="../index.html">Home</a> &rarr;
<a href="index.html#contents">MPM XML File Contents</a>
</p>

</body>

</html>