<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

<head>
	<meta http-equiv="content-type" content="text/html;charset=ISO-8859-1">
	<title>Format of Nairn-MPM-FEA Archive Files</title>
	<link rel="stylesheet" type="text/css" href="../help.css">
</head>

<body>

<p class="links">
<a href="../index.html">Home</a> &rarr;
Output Files
</p>

<h1>Output Files</h1>

<p>Finite element calculations using NairnFEA or material point method simulations using NairnMPM are written to one or more files. Visualization of results requires additional software to extract and plot the results. If you have a Macintosh computer with MacOS 10.4 or newer, all reults can be visualized using <a href="http://oregonstate.edu/~nairnj/NairnFEAMPM/index.html">NairnFEAMPM</a>. For other systems, you can use the java-based visualization tool (NairnFEAMPMViz) provided with the source code. Finally, you can use information on this page to write your own tools to extract results from output files for analysis and plotting. This page documents:</p>

<ul>
<li><a href="#feaoutput">NairnFEA output file</a></li>
<li><a href="#mpmoutput">NairnMPM output and archive files</a>.
<ul class="lev2args">
<li><a href="#versionid">Archive File Header</a></li>
<li><a href="#archsize">Record Size</a></li>
<li><a href="#sec1">Archive Format for Material Points</a></li>
<li><a href="#sec2">Crack Archive Format</a></li>
</ul></li>
</ul>

<h1><a name="feaoutput"></a>NairnFEA Output Files</h1>

<p>The results of FEA calculations are output to a single text file. The text file is human-readable and all analysis results are clearly labeled including information on units.
</p>

<p>The only unusual result is for <a href="../xmlformat/definefeamesh.html">imperfect interface elements</a>. Since these elements are not solid elements, they cannot define all components of the tensor. Instead, there is only a traction vector normal to the interfacial surface. The normal component of the traction vector is output as <code>sigma(xx)</code> (or <code>sigma(rr)</code> for axisymmetric analyses). The tangential component of the traction vector is output as <code>sigma(xy)</code> (or <code>sigma(rz)</code> for axisymmetric analyses).</p>

<h1><a name="mpmoutput"></a>NairnMPM Output File</h1>

<p>
The results of MPM calculations are output to a master text file and to a series of binary or text archive files. The text file defines the problem (lists the nodes, elements, materials, initial cracks, boundary conditions, <i>etc.</i>), describes the archive file format, and has a list of all archived files. The nodes, elements, and boundary conditions may be in the text file or in separate text files along with the archive files. When in separate files, the master text file will list the path to the needed file. The binary archive files have information about the solution for each material point. If there are cracks, the archive files also include the current crack locations and any calculated crack fracture parameters.
</p>

<p>
The information written to the archive files and the frequency for storing archived results are determined by the <a href="../xmlformat/index.html"><code>XML</code> input file</a>. The commands to select archive settings are in the <a href="../xmlformat/mpmheader.html">MPM Header</a>. Whether the nodes, elements, and boundary conditions are in the text file or in separate files is determined by the <a href="../xmlformat/definemesh.html"><code>&lt;Mesh&gt;</code></a> command
</p>

<h2>Output Text File Formats</h2>

<p>The results in text files are human readable and should be self explanatory.</p>

<h2>Output Binary Archive File Format</h2>

<p>The &quot;ARCHIVED ANALYSIS RESULTS&quot; section of the output text file will begin with lines that define the location and format of the binary archive files. Some typical information is:
</p>

<a name="masterformats"></a><pre>
Root file name: results/root.
Archive format: mYYYYNYYYNYYNNNNY
Crack archive format: mYYYN
</pre>

<p>The first line is the relative path name from the master text file to the archive files. In the above example, the archive files will be stored as <code>results/root.#</code> where <code>#</code> is the step number when the archive file was written. The &quot;<code>Archive format</code>&quot; defines the information <a href="#sec1">archived for each material point</a>. The &quot;<code>Crack archive format</code>&quot; defines the information <a href="#sec2">archived for each crack point</a>. The following sections defines the format of the binary archive files.</p>

<h3><a name="versionid"></a>Archive File Header</h3>

<p>The first 4 bytes of a binary archive file has the archive version ID as 4 characters. The current archive versions are:</p>

<dl>
<dt><code>none</code>, <code>ver1</code>, <code>ver2</code></dt>
<dd>These are old formats that are no longer supported and therefore no longer documented. (Note: if the master text file does not provide the archive and crack formats, it is certain those archive files have one of these old formats).
</dd>

<dt><code>ver3</code></dt>
<dd>These files have their format specified in the master text file (as listed <a href="#masterformats">above</a>).
</dd>

<dt><code>ver4</code></dt>
<dd>This format began at the end of NairnMPM 6.4.0 (October 2007). The difference from <code>ver3</code> is that the file includes a 64 byte header that includes information about the archive file format right in the file. The header information is
<ul class="lev2args">
<li> Bytes 1-4: the version ID or <code>ver4</code></li>
<li> Byte 5: number of characters in the archive format (A)</li>
<li> Byte 6 to (5+A): the archive format string</li>
<li> Byte (6+A): number of characters in the crack archive format (C)</li>
<li> Byte (7+A) to (6+A+C): the crack archive format</li>
<li> Byte (7+A+C): '2' or '3' for 2D or 3D analysis results</li>
<li> Byte (8+A+C) to 64: 0 bytes to fill out the header.</li>
</ul>
The <a href="#masterformats">archive format information</a> is still included in the master text file. In fact, if the text file and the archive file have different formats, it means that archive file does not belong to those results, which can be used as optional verification of file data.
</dd>

<dt><code>ver5</code></dt>
<dd>This format began in NairnMPM 6.7.0 (December 2008). It tacks on 5 more bytes of header information, still within a 64 byte header. The header information is
<ul class="lev2args">
<li> Bytes (8+A+C): '1' if analysis used structured grid (<i>i.e.</i>, grid created with the <code>GRID</code> command); '0' otherwise.</li>
<li> Byte (9+A+C) to (12+A+C): current time in ms (float using <a href="#endian">Endian style</a> from the archive format).</li>
<li> Byte (13+A+C) to 64: 0 bytes to fill out the header.</li>
</ul>
</dd>

<dt><code>ver6</code></dt>
<dd>The format began in NairnMPM 7.2.2 (January 2010). It did not change the header, but added an extra double in the default properties for 3D calculations to track all three rotation angles.</dd>
</dl>

<p>After the file's 4 or 64-byte header, the remainder of the file is a series of records with archived results for each material point and each crack particle. Programs that read archive files must read the archive and crack formats (either from the master text file or from the <code>ver4</code> file header) and support all <code>Y</code> and <code>N</code> options. If the number of characters in the specified format is less than the total number documented below, all extra characters are assumed to be <code>N</code>. In other words the binary achived file is assumed to be older, but backward compatible with this docmentation. The following sections give the details.</p>

<h3><a name="endian"></a>Byte Order Character</h3>

<p>The first character in each format string is either <code>m</code> or <code>i</code> to indicate the archive file byte order follows Macintosh chip methods or Intel chip methods. In Macintosh computers, bytes are stored from most significant to least significant byte. for example, the 4-byte integer representation for the number 1 (in hexadecimal) would be <code>0x00000001</code>. In contrast, the same number on an Intel chip would be <code>0x01000000</code>. Similarly, both Macintosh and Intel use IEEE methods for 8-byte double precision numbers, but the physical storage of bytes are in the opposite order.</p>

<p>If the byte order of the computer being used to read the archive files matches the byte order character, the files can be read as ordinary binary files. If the computer and the byte order character differ, the bytes for each element of the archived file have to be reversed as they are read.
</p>

<h3><a name="archsize"></a>Record Size</h3>

<p>
The information for each particle and each crack segment are stored as a series of binary records. All records are exactly the same size. The size is calculated from the sum of sizes required to store the information listed in the format strings. The following sizes assume <code>doubles</code> are 8 bytes, <code>ints</code> are 4 bytes (true on both 32 bit and 64 bit processors), and <code>shorts</code> are 2 bytes. Any byte with setting <code>N</code> will store no bytes. The following lists specify the number of bytes for setting <code>Y</code>. The numbers of bytes differ for 2D analyses <i>vs.</i> 3D analysis (in development).
</p>

<dl>

<dt>Archive Order Byte Requirements (2D Analyses)</dt>
<dd><ul class="lev2args">
  <li>Byte 2: 64 (cannot be <code>N</code> and <code>O</code> means old format which is no longer supported)</li>
  <li>Byte 3: 16</li>
  <li>Byte 4: 32</li>
  <li>Byte 5: 32</li>
  <li>Byte 6: 32</li>
  <li>Byte 7: 0 (it must be <code>N</code> for all <code>ver3</code> or newer files; a <code>Y</code> means an unsupported or invalid archive format)</li>
  <li>Byte 8: 8</li>
  <li>Byte 9: 8</li>
  <li>Byte 10: 8</li>
  <li>Byte 11: 0 (it must be <code>N</code> for all <code>ver3</code> or newer files; a <code>Y</code> means an unsupported or invalid archive format)</li>
  <li>Byte 12: 16</li>
  <li>Byte 13: 8</li>
  <li>Byte 14: 8 for 'Y', but 0, 8, 16, 24, or 32 (for other settings)</li>
  <li>Byte 15: 24</li>
  <li>Byte 16: 8</li>
  <li>Byte 17: 4</li>
  <li>Byte 18: 8</li>
  </ul>
</dd>

<dt>Archive Order Byte Requirements (3D Analyses)</dt>
<dd><ul class="lev2args">
  <li>Byte 2: 80 (<code>ver5</code> or older) or 88 (<code>ver6</code> or newer) (cannot be <code>N</code>)</li>
  <li>Byte 3: 24</li>
  <li>Byte 4: 48</li>
  <li>Byte 5: 48</li>
  <li>Byte 6: 48</li>
  <li>Byte 7: 0 (it must be <code>N</code> for all 3D archives)</li>
  <li>Byte 8: 8</li>
  <li>Byte 9: 8</li>
  <li>Byte 10: 8</li>
  <li>Byte 11: 0 (it must be <code>N</code> for all 3D archives)</li>
  <li>Byte 12: 0 (it must be <code>N</code> for all 3D archives)</li>
  <li>Byte 13: 8</li>
  <li>Byte 14: 8 for 'Y', but 0, 8, 16, 24, or 32 (for other settings)</li>
  <li>Byte 15: 32</li>
  <li>Byte 16: 8</li>
  <li>Byte 17: 4</li>
  <li>Byte 18: 24</li>
  </ul>
</dd>


<dt>Crack Archive Order Byte Requirements (2D Analyses)</dt>
<dd><ul class="lev2args">
  <li>Byte 2: 88 (cannot be <code>N</code> and <code>O</code> means old format not longer supported)</li>
  <li>Byte 3: 16</li>
  <li>Byte 4: 16</li>
  <li>Byte 5: 20</li>
  </ul>
</dd>

<dt>Crack Archive Order Byte Requirements (3D Analyses)</dt>
<dd>3D calculations currently do not allow cracks.
</dd>


<dt>Record Size in Archive File</dt>
<dd>The record size used in the file is the maximum of the archive order and crack archive order requirements for the dimensionailty of the analysis. Typically the crack archive will require less bytes than material point archive, but its record will still be the same size as the material point archive.</dd>

</dl>


<a name="sec1"></a><h3>Archive Format for Material Points</h3>

<p>
The following items may be archived for each material point. This section list the quantity that is archived and its units in the archive file. The data appear in each record in the following order, but each item only appears if the archive setting for that byte is <code>Y</code>.
</p>

<dl>

<dt>Byte 2: Default Properties</dt>
<dd>This setting must be <code>Y</code>. A setting of <code>O</code> is means an old archive format that is no longer supported. The default properties are:

<pre class="near">
int inElem - element number containing the material point
double mp - mass (g)
short matnum - material number
short unused - not used
double anglez - material angle (for anisotropic materials) (degrees)
2D any version or 3D in ver5 or older has:
   double thickness - thickness (mm) (or 0 in 3D)
3D in ver6 or newer replaces thickness with two more angles:
   double angley - material angle (for anisotropic materials) (degrees)
   double anglex - material angle (for anisotropic materials) (degrees)
double x - current x position (mm)
double y - current y position (mm)
double z - current z position (mm) (3D only)
double origx - original x position (mm)
double origy - original y position (mm)
double origy - original z position (mm) (3D only)
</pre>
</dd>

<dt>Byte 3: Particle velocity</dt>
<dd>Setting <code>Y</code> stores components of particle velocity:

<pre class="near">
double velx - x direction velocity (mm/sec)
double vely - y direction velocity (mm/sec)
double vely - z direction velocity (mm/sec) (3D only)
</pre>
</dd>

<dt>Byte 4: Particle stress</dt>
<dd>Setting <code>Y</code> stores components of particle stress:

<pre class="near">
double stressxx - x direction normal stress (Pa)
double stressyy - y direction normal stress (Pa)
double stresszz - z direction normal stress (Pa)
double stressxy - x-y plane shear stress (Pa)
double stressxz - x-z plane shear stress (Pa) (3D only)
double stressyz - y-z plane shear stress (Pa) (3D only)
</pre>
</dd>

<dt>Byte 5: Particle strain</dt>
<dd>Setting <code>Y</code> stores components of particle strain, which is elastic strain for plasticity materials:

<pre class="near">
double strainxx - x direction normal strain (dimensionless)
double strainyy - y direction normal strain (dimensionless)
double strainzz - z direction normal strain (dimensionless)
double strainxy - x-y plane shear strain (dimensionless)
double strainxz - x-z plane shear strain (dimensionless) (3D only)
double strainyz - y-z plane shear strain (dimensionless) (3D only)
</pre>
</dd>

<dt>Byte 6: Particle plastic strain</dt>
<dd>Setting <code>Y</code> stores components of particle plastic strain:

<pre class="near">
double plstrainxx - x direction plastic normal strain (dimensionless)
double plstrainyy - y direction plastic normal strain (dimensionless)
double plstrainzz - z direction plastic normal strain (dimensionless)
double plstrainxy - x-y plane plastic shear strain (dimensionless)
double plstrainxz - x-z plane plastic shear strain (dimensionless) (3D only)
double plstrainyz - y-z plane plastic shear strain (dimensionless) (3D only)
</pre>
</dd>

<dt>Byte 7: Original Position</dt>
<dd>This setting should always be <code>N</code> otherwise the archive file has an unsupported or invalid format.
</dd>

<dt>Byte 8: Particle external work</dt>
<dd>Setting <code>Y</code> stores total external work (which is only non-zero if the material point had an applied external force):

<pre class="near">
double extwork - cumulative external work (J)
</pre>
</dd>

<dt>Byte 9: Particle temperature</dt>
<dd>Setting <code>Y</code> stores particle temperature:

<pre class="near">
double temperature - temperature difference (Celsius)
</pre>
</dd>

<dt>Byte 10: Particle plastic energy</dt>
<dd>Setting <code>Y</code> stores particle plastic energy:

<pre class="near">
double plastEnergy - cumulative plastic energy (J)
</pre>
</dd>

<dt>Byte 11: Future Expansion</dt>
<dd>This setting should always be <code>N</code> otherwise the archive file has an unsupported or invalid format.
</dd>

<dt>Byte 12: Particle total shear strain components (du/dy and dv/dx)</dt>
<dd>Setting <code>Y</code> stores two components of total strain gradient that combine to give total <code>x-y</code> shear strain. Only useful in 2D analysis and can get same information by archiving rotational strain instead:

<pre class="near">
double dudy - Strain gradient term du/dy (dimensionless)
double dvdx - Strain gradient term dv/dx (dimensionless)
</pre>
</dd>

<dt>Byte 13: Particle strain energy</dt>
<dd>Setting <code>Y</code> stores particle strain energy:

<pre class="near">
double strainEnergy - cumulative strain energy (J)
</pre>
</dd>

<dt>Byte 14: Particle history variable 1</dt>
<dd>Up to four history variables may be stored. A setting of 'N' stores none; a setting of 'Y' stores history variable 1; and the following settings store any combination of the first four:
<pre class="near">
'1' or 'Y' - history 1
'2' - history 2
'3' - history 1 and 2
'4' - history 3
'5' - history 1 and 3
'6' - history 2 and 3
'7' - history 1, 2, and 3
'8' - history 4
'9' - history 1 and 4
':' - history 2 and 4
';' - history 1, 2, and 4
'&lt;' - history 3 and 4
'=' - history 1, 3, and 4
'&gt;' - history 2, 3, and 4
'?' - history 1, 2, 3, and 4
</pre>
<p>The stored variables are determined by a bit-wise check on the four least-significant bits of the ASCII value of the setting minus ASCII for '0' = 0x30. History variables are only meaningful for certain <a href="../xmlformat/definematl.html">material</a> types. The units are determined by the material and all are doubles:
</p>
<pre class="near">
double history1 - particle history information
double history2 - particle history information
double history3 - particle history information
double history4 - particle history information
</pre>
</dd>

<dt>Byte 15: Particle concentration and concentration gradient</dt>
<dd>Setting <code>Y</code> stores particle concentration and concentration gradient. These values will only be non-zero when diffusions calculations are activated:

<pre class="near">
double concentration - particle concentration
double dcdx - particle concentration gradient (dc/dx)
double dcdy - particle concentration gradient (dc/dy)
double dcdz - particle concentration gradient (dc/dz) (3D only)
</pre>
</dd>

<dt>Byte 16: Particle thermal energy</dt>
<dd>Setting <code>Y</code> stores approximate energy to to temperature change:

<pre class="near">
double thermalEnergy - cumulative thermal energy (J)
</pre>
</dd>

<dt>Byte 17: Element crossings</dt>
<dd>Setting <code>Y</code> stores number of times this particle has crossed element boundaries:
<pre class="near">
int elemCrossings - cumulative element crossing
</pre>
</dd>


<dt>Byte 18: Rotational strain</dt>
<dd>Setting <code>Y</code> stores <i>initial</i> material angle(s). The evolving angles are always stored in the material angle properties:
<pre class="near">
double anglez0 - initial material angle z (degrees)
double angley0 - initial material angle y (degrees) (3D Only)
double anglex0 - initial material angle x (degrees) (3D Only)
</pre>
The rotational engineering strains are <code>&omega;<sub>xy</sub> = -&pi;*(anglez-anglez0)/90</code>, <code>&omega;<sub>xz</sub> = &pi;*(angley-angley0)/90</code>, and <code>&omega;<sub>yz</sub> = -&pi;*(anglex-anglex0)/90</code>, which are twice the tensorial rotational strains.
</dd>

</dl>

<a name="sec2"></a><h3>Crack Archive Format</h3>

<p>
The following items may be archived for each crack point. This section lists the quantity that is archived and the units for that item. Crack archives are currently only in 2D analyses. The data appear in each record in the following order, but each item only appears if the archive setting for that byte is <code>Y</code>.
</p>

<dl>

<dt>Byte 2: Default Properties</dt>
<dd>This setting must be <code>Y</code> or <code>O</code>. A setting of <code>O</code> means an old archive format that is no longer supported. The default parameters that are archived as crack point properties are:

<pre class="near">
int inElem - element number containing the crack point
int tipMatnum - crack tip material ID (1 based) or -1 for no material or -2 for exterior crack tip
spacer - for alignment with material point records, unused bytes (count = sizeof(double)-sizeof(int))
short marker - -1 for first point in crack, -2 for other points
short tractionMat - traction law material number (&lt;=0 for no tractional law)
double x - current x position (mm)
double y - current y position (mm)
double origx - original x position (mm)
double origy - original y position (mm)
int inElemAbove - element number containing the crack top surface point
double xAbove - current x position of crack top surface (mm)
double yAbove - current y position of crack top surface (mm)
int inElemBelow - element number containing the crack bottom surface point
double xBelow - current x position of crack bottom surface (mm)
double yBelow - current y position of crack bottom surface (mm)
</pre>
</dd>

<dt>Byte 3: J Integral</dt>
<dd>Setting <code>Y</code> stores two components of J Integral:

<pre class="near">
double J1 - J Integral or energy release rate (J/m^2)
double J2 - Second component of J Integral calculation (J/m^2) (when no crack propagation)
              or the actual J released (J/m^2) the last time the crack propagated
              (when propagation is activated)
</pre>
</dd>

<dt>Byte 4: Stress Intensity Factor</dt>
<dd>Setting <code>Y</code> stores two components of stress intensity factor:

<pre class="near">
double KI - Mode I stress intensity factor (MPa sqrt(m))
double KII - Mode II stress intensity factor (MPa sqrt(m))
</pre>
</dd>

<dt>Byte 5: Dynamic Energy Balance Results</dt>
<dd>Setting <code>Y</code> stores information about crack growth using <a href="../xmlformat/mpmheader.html#cracks">criterion</a> 3:

<pre class="near">
int counter - count of crack increments
double released - energy released (J/m^2)
double absorbed - energy absorbed (J/m^2)
</pre>
</dd>
</dl>

<p class="links">
<a href="../index.html">Home</a> &rarr;
Output Files
</p>

</body>

</html>