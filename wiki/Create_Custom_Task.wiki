#summary Create a new custom task for NairnMPM
#labels NairnMPM

= Introduction =

This page explains how to create a new custom task and integrate it into NairnMPM. Custom tasks can be used to add many new features to the code

= Basic Steps =

  # Create new class that inherits from the `CustomTask` class
  # Create instance of task in `MPMReadHandler::myStartElement()` if the input file want to use the new task
    * See section for tag 'Schedule'
    * New instance created on `name` attribute of the tag
    * This change should be the only change done to toe core code.
  # Support methods listed below (as needed) in the new custom task. Most methods return the `nextTask` because the calling code uses it when it loops over all custom tasks. Any that are not needed can be omitted because the `CustomTask` class provides methods that simply returns the `nextTask`. Custom tasks are done in step 7 of the core time step in `MPMStep()`. That step is near the end of the time step.

== Task Parameters ==

If the custom task ha parameters, implement them by reading them with:

  * `char *CustomTask::InputParam(char *pName,int &input)` - Check the parameter name. If it matches a defined task parameter name set `input` to the kind of pointer and return the actual pointer to the class variable for that parameter. If no match return `NULL`. This is the only method that does not return `nextTask`.

== Initialize ==

  * `CustomTask *CustomTask::Initialize()` - Called once at beginning of an MPM analysis. Do any initialization and print info about the task using `cout` - anything printed will by in the custom tasks section of the results file.

== Step 7a: Prepare custom tasks == 

  * `CustomTask *MyTask::PrepareForStep(bool &doExtraps)` -  Called in `MPMStep()` just before custom tasks are done. You can use this to initialize variables. If the task needs extrapolations to the grids or summations over particles, set `doExtraps` to `TRUE` (setting to `FALSE` does nothing).

== Step 7b: Custom extrapolatlions == 

The following methods are in a loop which allows a custom task to extrapolate some property to the grid or do some other calculation requiring loop over all particles:

  * `CustomTask *MyTask::BeginExtrapolations(void)` - Called once before extrapolation loop begins. Initialize any required variables.
    
  * `CustomTask *MyTask::NodalExtrapolation(NodalPoint *ndmi,MPMBase *mpnt,short vfld,int matfld,double wt)` - Called repeatedly in the loop for each particle/node pair. `vfld` is the velocity field, `matfld` is material valocity filed (when in multimaterial mode), and `wt` is the weight (or mass times shape function). Can use to extrapolate particle data to the grid.

  * `CustomTask *CustomTask::ParticleCalculation(NodalPoint *ndmi,MPMBase *mpnt,short vfld,int matfld, double fn,double xDeriv,double yDeriv,double zDeriv)` - Called repeatedly in the loop for each particle/node pair. `vfld` is the velocity field, `matfld` is material valocity filed (when in multimaterial mode), and `wt` is the weight (or mass times shape function). Can use to extrapolate nodal values to the particles.

  * `CustomTask *MyTask::ParticleExtrapolation(MPMBase *mpnt)` - Called once for each particle. Can use to sum any quantity over the particles.
    
  * `CustomTask *MyTask::EndExtrapolations(void)` - Called once when extrapolations are over. Use to free anything allocated during the extrapolations or to do some calculations.

== Step 7c: Custom Calculations == 

  * `CustomTask *MyTask::StepCalculation(void)` - This method is the usually the main part of any custom task. Do the desired calculations. The code will have access to all global variables.
    
== Step 7d: Custom Finish == 

  * `CustomTask *MyTask::FinishForStep(void)` - Called once when all custom tasks are done. Use to free up any memory still allocated by the task.