#summary Creating a new element for NairnFEA
#labels NairnFEA

= Introduction =

This page explains how to create a new type of element for NairnFEA.

= Add an Element for NairnFEA and/or NairnMPM =

The following sections described the various tasks needed to support a new element type in NairnFEA and NairnMPM. Since NairnMPM is typcially based only on 4-node 2D and 8-node 3D elements, these tasks are mostly about adding them for NairnFEA.

== Create New Element Class Source Files ==

The first step is to create a new class that is a subclass of an existing element or a subclass of `ElementBase` if it is  new class of element. The steps for this task are:

  # Define new source for the element and create `.cpp` and `.hpp` files
  # Define a constant (numeric ID) for the new element. To avoid potential future conflicts, all these constants are defines in `ElementBase.hpp`.
  # Write two constructors for the element class:
    * `NewElement(int eNum, int *eNode)` - for MPM, the constructor arguments are the element number and an integer array of node numbers.
    * `NewElement(int eNum, int *eNode, int eMat,double eAng,double eThick)`- for FEA, the additional arguments are the material number, the angle (for anisotropic materials), and the thickness (for plane strain or plane stress calculations).
  # Override and implement (as needed) the following methods:
    * `ElementName(void)` - return numeric code defined in `ElementBase.hpp`
    * `NumberNodes(void)` - return number of nodes
    * `NumberSides(void)` - return number of sides
    * `GetArea(void)` - element area (only used in MPM to decide on wave speed)
    * `FaceNodes(void)` - return number of nodes on each face
    * `PtInElement()` - if point is in any element return 1 otherwise 0
    * `ShapeFunction()` - load shape functions, their derivatives (if requested), and data for axisymmetric calculations (if requested).

== Create Instances of Elements ==

During initialization of a calculation, the mesh is created and divided into elements. The tasks in this section are needed to be able to add the new element to a mesh.

  # Include new elements' header file in `ElementsController.cpp`.
  # The `ElementsController.cpp` code handles all tasks when creating elements for a mesh. New elements will need some element-specific modifications to this source file withinthe following subroutines:
    * `ElementsCompatible()` - document elements that are compatible in same mesh with new element
    * `HasMidsideNodes()` - return true if new element has mid side nodes
    * `ElementSides()` - return number of sides for the new element
    * `ElementBase *MeshElement()` - creates elements for MPM grid. The input parameters are the element ID, the element number, and an integer array of nodes. To use the element in MPM grids, add a `case` to the `switch` block for the new element and return the element instance. Note: MPM currently only allow 4 node quadrilateral elements in 2D and 8 node brick elements is 3D. Before new elements can be used, the MPM input commands will need a new attribute or command related to the grid to specify the new element type. The changes are very minor.
    * `int MeshElement()` - creates elements for FEA mesh. The input parameters are 4 or 8 nodes counter clockwise around a quadrilateral area (for interface elements it is 4 or 6 nodes counter clockwise back and forth along the interface). To use the element in FEA meshes, add a `case` to the `switch` block for the new element. See existing example for needs. The triangular elements need to create two elements in the provided quadrilateral. If you omit this change, the element cannot be used in generated FEA meshes.
    * `CreateElement()` - Elements can be created from XML `elem` command, which has the format
{{{
<elem type='2' matl='1' angle='0' thick='10'>1,5,69,68</elem>
}}}
    where type is element code (numeric ID defined above), `matl` is numerical material ID, `angle` is material angle for anisotropic materials, and `thick` is thickness in mm. The data is list of node numbers (delimited by white space, commas, colons, or semicolons). This creating method is only used when explicitly generating meshes, which is very uncommon in FEA and not recommended for MPM (because it cannot use GIMP). Support for the new element in this subroutine is therefore option. To provide support, and a new `case` to the `switch` block to verify the right number of nodes were received and then to create an instance of the new element.

= Support or Element-Based Calculations =

This section has changes needed for calculations that depend on the element type. For MPM, the calculations only involve shape functions. For FEA, they involve boundary conditions, shape functions, stiffness matrix, and output of element properties.

== Allocate `R` Vector ==

  # Support `CalcEdgeLoads()` which is called by `GetConsistentLoads(re,np)` - this method is called by `ForcesOnEdges()` to support stress based boundary conditions on an element edge (FEA only).

== Shape Functions ==

  # FEA - find Shape functions, their derivatives, and terms for axisymmetric calculations in `ShapeFunction()`.
  # MPM - MPM elements have more shape function needs to support GIMP calculations. The details are not documented here.
	
== Get Element Stiffness Matrix ==

  # Calculate element stiffness matrix in `Stiffness()` - called in `BuildStiffnessMatrix()`. If element uses `IsoparametricStiffness()` then need to set `numGauss` and `gaussSet` (FEA only).

== Output Forces and Stresses ==

  # Support `ForceStress()` - called in `ForceStressEnergyResults(void)` (FEA only).
  # If use `IsoparametricForceStress()` need to fill in option for extrapolation to nodes for element type. Also need to set `numGauss` and `gaussSet`(FEA only).