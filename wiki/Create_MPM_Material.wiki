#summary Creating a New Material Type for NairnMPM
#labels NairnMPM

= Introduction =

These notes explain how to create a new material class for use in NairnMPM.

= Getting Started =

The first steps are to add a new class to NairnMPM and to allow input command files to use that material. These steps involve creating the source code and some edited of the core code to add the new material class. Those steps are defined in this section.

== Class Source Code ==

The best way to create the source code is to duplicate the `NewMaterial.cpp` and `NewMaterial.hpp` files, which are templates for a new material class. Edit the files and change `NewMaterial` to the new material's class name. The template is a subclass of `MaterialBase`. Normally the new material will be a subclass of another class. If so, change `MaterialBase` references, as needed, to the actual parent class. These changes are needed whenever a method in the new material class needs to pass control to its immediate super class.

== Material Class Hierarchy ==

The following outline shows all materials in `nairn-mpm-fea`as a class hierarchy. Materials in UPPERCASE are actual materials. Materials in mixed case are abstract classes. Materials in <font color="green">green</font> are in both FEA and MPM; materials in <font color="red">red</font> are only in FEA; all the rest are only in MPM. The new material should be inserted into this hierarchy and it should define a new, unique constant (in UPPERCASE) for that material. The current materials use numbers 1 through 21 (except for 6). This new constant should replace the `NEWMATERIAL` constant in the new `.hpp`. Futhermore, to allow this number in input command files, it must be added as an option for the `Material` command in the `DTD` file.

  * <font color="green">`MaterialBase`</font>
    * <font color="green">`Elastic`</font>
      * <font color="green">`ISOTROPIC=1`</font>
        * `IsoPlasticity`
          * `VONMISESHARDENING=9`
          * `MGSCGLMATERIAL=17`
            * `SLMATERIAL=18`
          * `JOHNSONCOOK=16` 
        * `BISTABLEISO=10`
      * <font color="green">`TRANSISO1(2)=2,3`</font>
        * <font color="green">`ORTHO=4`</font>
          * `AnisoPlasticity` 
            * `HILLPLASTIC=15`
              * `WOODMATERIAL=19`
    * `VISCOELASTIC=7`
    * `HyperElastic`
      * `MOONEYRIVLIN=8`
      * `HEANISOTROPIC=21`
    * <font color="red">`INTERFACEPARAMS=5`</font>
    * `RIGIDMATERIAL=11`
    * `TractionLaw`
      * `COHESIVEZONEMATERIAL=12`
        *`LINEARTRACTIONMATERIAL=13`
        * `TRILINEARTRACTIONMATERIAL=20`
      * `CUBICTRACTIONLAW=14`

== Editing Required in Core Code ==

Almost all coding will be done in the new material class files, but for that material to be recognized as an option in NairnMPM, a few places in the core code have to be edited first. Theses should be the only changes need outside the new material class files.

  # In `MaterialController::AddMaterial(int matID,char ``*``matName)`- - add a new case in the `switch(matID)` section to call the default constructor of the new material when `matID` matches the new material constant defined in the previous section.
  # Include the new material's header file at the top of `MaterialController.hpp`

== Compiling with `make` Command ==

If you want to be able to do command-line compiling using the 'make command, the new material source files needed to add to the `makefile`. The steps are best done by comparing to a similar material's files in the `makefile`' The main steps are are to edit the `makefile` and do:

  # Add the new material's header file to the header file's needed to compile `MaterialController.hpp`
  # Compile the new material's source file (see a similar material for example of what is needed).

= Writing the Material Class Source Code =

The remaining steps can usually all be done by editing only the material's source code file. The requirements and optional methods are described in the following sections. This stage involves editing the template file created above and customizing the listed methods and/or deleting optional methods that are not needed.

== Basic Class Accessors ==

These methods (required unless specified as optional) return basic facts about the material:

  * `const char *MaterialType(void)` - return a short name to describe the material. This string is printed with material properties in the output of simulations.
  * `int MaterialTag()` - return the constant define above.
  * `bool ThreeDMaterial(void)` (optional) - return `false` is this material does not support `MPMConstLaw()` for three dimensional simulations. If it does support 3D you can delete the method because the `MaterialBase` class returns `true'.
  * `double WaveSpeed(bool)` - Return the maximum wave speed for material in mm/sec. This method is called once for each material point at start of calculation and after material properties have been defined. If the wave speed might change during the simulation, be conservative and return the maximum possible save speed. The parameter is `true` for 3D calculations or `false` for 2D. This speed is needed to pick the time step for explicit calculations.
  * `double ShearWaveSpeed(bool)` (optional) - Return the shear wave speed for the material. This method is only used by silent boundary conditions. The `MaterialBase` class returns `WaveSpeed()/sqrt(3)`. You only need to override this method if you want a better value.
  * ` double MaximumDiffusion(void)` (optional) - return maximum diffusion constant in cm<sup>2</sup>/sec. This method is called once for each material at the start of the calculation and after material properties are defined. The `MaterialBase` class returns the appropriate result for isotropic materials. You only need to override if you need a different result.
  * `double MaximumDiffusivity(void)` (optional) - return maximum thermal diffusivity in cm<sup>2</sup>/sec = k/(100 rho C<sub>p</sub>). This method is called once for each material at the start of the calculation and after material properties are defined. The `MaterialBase` class returns the appropriate result for isotropic materials. You only need to override if you need a different result.

== Creating New Material Properties ==

Usually a newly-created material type will have additional material properties. To create such properties, you need the following steps for each one:

  # Define the property variable in the `.hpp` file (usually scalars). It is usually best to define these properties `protected` section of the class, although `public` properties are sometimes needed.
  # To allow the property in input files, select a unique property name. Define that property in the `DTD` file, usually as a simple `XML` element like `<!ELEMENT prop (#PCDATA)>`, where `prop` is the new property name. In addition, add that property's name to the list of allowed elements within the `Material` element definition in the `DTD` file.
  # Edit the new material's `InputMat()` method and look for that property by name. If found, set pointer type (_e.g._, `DOUBLE_NUM` or `INT_NUM`) and return a pointer to the class variable define in the `.hpp` file..
  # If desired, set default value for the property in the material's constructor method.
  # If desired, check that the final value is acceptable in the `VerifyProperties()` method. If it is not, return an error message as a string.
  # Print the property to the output file (usually in the `PrintMechanicalProperties()` method)
  # Use it as needed in the material response methods

== Traction Law Materials (only for traction law materials) ==

There is currently no template code for traction law materials. One should be created the next time a new traction law is needed. Here are some notes on traction law methods

  * The base class for all traction laws in `TractionLaw.cpp`. It handles some things:
    # Overrides `MPMConstLaw()` with empty methods because not needed for traction laws
    # Blocks transport law printing (not needed) and no other transport stuff is needed either
  * `VerifyProperties()` - This method should check properties, but do not call `MaterialBase` class method. It is OK to fall up to `TractionLaw` because that class will block further calls.
  * `InitialLoadMechProps()` - Never called for traction laws
  * `CrackTractionLaw()` - Calculate tractions for current opening and shear cod and will be the core coding needed for new traction laws.
  * `CrackTractionEnergy()` - Calculate full energy or released energy for current COD.

== Material Methods - Calculations called during MPM steps ==

Below is summary of key methods involved with MPM calculations in each time step. The first four are called first to allow update of material properties when those material properties depend on the current state of the particle (_e.g._, properties that depend on temperature, moisture, orientation, or current particles stress or stain). Once the properties are set, one of the last two are calculated to implement the constitutive law.

  * `virtual void LoadMechanicalProps(MPMBase *,int)` - This method is called just before the constitutive law on each time step. You can set any parameters for the material that depend on the current state of the particle. Things that never change (_i.e._, properties that are independent of particle state) should be calculated in `InitialLoadMechProps()` instead. NOTE: Some materials also used in FEA make use of `LoadMechProps()` in this task, but that method is limited to 2D because it only inputs a single rotation about the `z` axis.
  * `virtual void LoadTransportProps(MPMBase *)` - This method is called when looping over material points to store parameters needed in transport calculations (tensors). It is called prior to the transport tasks to `AddForces()`. It is only needed for anistropic materials or for materials whose transport properties change depending on particle state. This method should load the required values into `diffusionTensor` and `kCondTensor` in the `MaterialBase` class. Transport properties that never change (_i.e._, independent of particle state) should be calculated in `InitialLoadTransProps()` instead.
  * `virtual double GetHeatCapacity(MPMBase *)` - When conduction is activated, this method is called before calculations that depend on heat capacity C<sub>P</sub>. If C<sub>P</sub> changes with particle state, return current heat capacity using units of J/(g-K). This method can be ignored if C<sub>P</sub> is a constant (note that the `heatCapacity` variable in `MaterialBase` is internally stored in J/(g-K) during calculations, although it is input as J/(kg-K)).
  * `virtual double GetHeatCapacityVol(MPMBase *mptr)` - This method has the same function as `GetHeatCapacity()` except applies to constant volume heat capacity C<sub>V</sub>, and the base class variable is `heatCapacityVol`.
  *  `virtual void MPMConstLaw(MPMBase *,double,double,double,double,double,int)` - This methods applies constitutive law for the material in 2D calculations and updates all needed particle properties. The required updates include stress (should be a specific stress), strain, plastic strain, rotational strain, strain energy, plastic energy, dissipated energy (dissipated needed if want to couple to conduction), and any material history dependent variables defined for the material. To support thermal and solvent expansion, include their effect on the constitutive law. Then input `dvij` are components of velocity gradient times the time step, which gives components of the deformation gradient change.
  * `virtual void MPMConstLaw(MPMBase *,double,double,double,double,double,double,double,double,double,double,int)` - This method is the same as the previous method except it applies to 3D calculations and the extra input variables define the full change in the 3D deformation gradient.
		

== Fracture Methods ==

The methods deal with fracture and are currently handled for all materials in the base class.

  * `virtual MaterialBase *SetFinalPropagate(void)` - hould be enough in default method to set up fracture criterion
  * `virtual Vector ConvertJToK(Vector,Vector,Vector,int)` - Convert J Integral to K or stress intensity factor. Default returns zero.
  * `virtual int CriterionNeeds(void)` - Determines if J and/or K is needed.
  * `virtual int ShouldPropagate(CrackSegment *,Vector &,CrackHeader *,int np)` - Determine if crack chould grow.
  * `virtual bool ControlCrackSpeed(CrackSegment *,double &)` - Adjust crack speed
  * `virtual bool SelectDirection(CrackSegment *,Vector &,CrackHeader *)` - 
  * `virtual void HoopDirection(double,double,Vector *)` - 
  * `void RotateDirection(Vector *,double,double)` - 
  * `virtual double CrackPropagationAngleFromStrainEnergyDensityCriterion(double,double,double)` -  - Used in one fracture criterion
  * `static const char *PreferredDirection(int)` - 