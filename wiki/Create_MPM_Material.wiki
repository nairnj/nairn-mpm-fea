#summary Creating a New Material Type for NairnMPM
#labels NairnMPM

= Introduction =

These notes explain how to create a new material class for use in NairnMPM.

= Getting Started =

The first steps are to add a new class to NairnMPM and to allow input command files to use that material. These steps involve creating the source code and some editing of the core code to add the new material class. Those steps are defined in this section.

== Class Source Code ==

The best way to create the source code is to duplicate the `NewMaterial.cpp` and `NewMaterial.hpp` files, which are templates for a new material class. Edit the files and change `NewMaterial` to the new material's class name. The template is a subclass of `MaterialBase`. Normally the new material will be a subclass of another class. If so, change `MaterialBase` references, as needed, to the actual parent class. These changes are needed whenever a method in the new material class needs to pass control to its immediate super class.

== Material Class Hierarchy ==

The following outline shows all materials in `nairn-mpm-fea` as a class hierarchy. Materials in UPPERCASE are actual materials. Materials in mixed case are abstract classes. Materials in <font color="green">green</font> are in both FEA and MPM; materials in <font color="red">red</font> are only in FEA; all the rest are only in MPM. The new material should be inserted into this hierarchy and it should define a new, unique constant (in UPPERCASE) for that material. The current materials use numbers low numbers (starting with 1); those working on custom materials should probably use large number (>100). This new constant should replace the `NEWMATERIAL` constant in the new `.hpp`.

  * <font color="green">`MaterialBase`</font>
    * <font color="green">`Elastic`</font>
      * <font color="green">`ISOTROPIC=1`</font>
        * `ISOPLASTICTY=9`
          * `MGEOSMATERIAL=17`
        * `BISTABLEISO=10`
      * <font color="green">`TRANSISO1(2)=2,3`</font>
        * <font color="green">`ORTHO=4`</font>
          * `AnisoPlasticity` 
            * `HILLPLASTIC=15`
              * `WOODMATERIAL=19`
    * `VISCOELASTIC=7`
    * `HyperElastic`
      * `MOONEYRIVLIN=8`
      * `HEISOTROPIC=24`
      * `HEANISOTROPIC=21` (future development)
      * `IDEALGASMATERIAL=22`
    * <font color="red">`INTERFACEPARAMS=5`</font>
    * `RIGIDMATERIAL=11`
    * `TractionLaw`
      * `COHESIVEZONEMATERIAL=12`
        * `LINEARTRACTIONMATERIAL=13`
        * `TRILINEARTRACTIONMATERIAL=20`
        * `COUPLEDSAWTOOTHMATERIAL=23`
      * `CUBICTRACTIONLAW=14`

== Editing Required in Core Code ==

Almost all coding will be done in the new material class files, but for that material to be recognized as an option in NairnMPM, a few places in the core code have to be edited first. Theses should be the only changes needed outside the new material class files.

  # In `MaterialController::AddMaterial(int matID,char ``*``matName)`- - add a new case in the `switch(matID)` section to call the default constructor of the new material when `matID` matches the new material constant defined in the previous section.
  # Include the new material's header file at the top of `Common/Read_XML/MaterialController.cpp`

== Compiling with `make` Command ==

If you want to be able to do command-line compiling using the `make` command, the new material source files needed to add to the `makefile`. The steps are best done by comparing to a similar material's files in the `makefile`. The main steps are are to edit the `makefile` and do:

  # Add the new material's header file to the header file's needed to compile `MaterialController.hpp`
  # Compile the new material's source file (see a similar material for example of what is needed).

= Writing the Material Class Source Code =

The remaining steps can usually all be done by editing only the material's source code file. The requirements and optional methods are described in the following sections. This stage involves editing the template file created above and customizing the listed methods and/or deleting optional methods that are not needed.

== Basic Class Accessors ==

These methods (required unless specified as optional) return basic facts about the material:

  * `const char *MaterialType(void)` - return a short name to describe the material. This string is printed with material properties in the output of simulations.
  * `int MaterialTag()` - return the constant defined above.
  * `double WaveSpeed(bool,MPMBase *)` - Return the maximum wave speed for material in mm/sec. This method is called once for each material point at start of calculation and after material properties have been defined. If the wave speed might change during the simulation, be conservative and return the maximum possible save speed. The first parameter is `true` for 3D calculations or `false` for 2D. This speed is needed to pick the time step for explicit calculations. The second parameter is pointer to a material point in case the wave speed depends on the initial particle state. This method is also used in some crack propagation methods. If the material supports crack propagation, make sure it give good results for these uses.
  * `double MaterialBase::CurrentWaveSpeed(bool,MPMBase *)` (optiona) - Return the current wave speed, which might depend on particle state. This method is used by the `AdjustTimeStep` task to change time step as needed; without this method, the time step will not adjust for the material.
  * `double ShearWaveSpeed(bool)` (optional) - Return the shear wave speed for the material. This method is only used by silent boundary conditions. The `MaterialBase` class returns `WaveSpeed()/sqrt(3)`. You only need to override this method if you want a better value. Also note that silent boundary conditions only work for isotropic materials.
  * ` double MaximumDiffusion(void)` (optional) - return maximum diffusion constant in cm<sup>2</sup>/sec. This method is called once for each material at the start of the calculation and after material properties are defined. The `MaterialBase` class returns the appropriate result for isotropic materials. You only need to override if you need a different result.
  * `double MaximumDiffusivity(void)` (optional) - return maximum thermal diffusivity in cm<sup>2</sup>/sec = k/(100 rho C<sub>p</sub>). This method is called once for each material at the start of the calculation and after material properties are defined. The `MaterialBase` class returns the appropriate result for isotropic materials. You only need to override if you need a different result.
  * `double GetCurrentRelativeVolume(MPMBase *)` (optional) - Return current relative volume to be used to convert tracked stress to true stress. Low strain materials track stress/initial density and they should return 1 (which is what base material class returns). Large deformation materials should be tracking specific Cauchy stress (= Kirchoff stress/initial density) and therefore should return relative volume (_i.e._, initial density/current density)

== Creating Material Properties ==

Usually a newly-created material type will have additional material properties. To create such properties, you need to define them, allow them in input command files (_i.e._, update the `DTD` file), set them in the material class file, validate them, and finally use them in calculation. The following steps are needed:

  # Define the property variable in the `.hpp` file (usually `int` or `double`). It is best to define these properties in the `protected` section of the class, although `public` properties are sometimes needed (and are allowed)
  # To allow the property in input files, select a unique property name (the name may or may not be same as variable in previous step). Define that property by name in the `DTD` file, usually as a simple `XML` element like `<!ELEMENT prop (#PCDATA)>`, where `prop` is the new property name.
  # Add that property's name to the list of allowed elements within the `Material` element definition in the `DTD` file.
  # Set some default value for the new property variable in the new material's constructor method.

Once a property variable and name are defined, you set that variable, check, and use it with the following methods:

  * `char *InputMat(char *xName,int &input)` - if `xName` string matches a property name for this material, set `input` to `DOUBLE_NUM` or `INT_NUM` (depending on the type of variable) and return a pointer to the class variable for that property. If `xName` is not a recognized property return `InputMat(xName,input)` for the super class to look for their valid property types.
  * `const char *VerifyProperties(int np)` (optional) - this method is called after input file is read but before the new material is printed to the results file. You can use this method to verify the input material properties are physically allowed. If not, return a string with an error message and the simulation will be aborted. If there are no errors, return superclass call to let it check properties as well. The input `np` is a constant for the analysis type (_e.g._, plane stress, plane strain, 3D, _etc._). If the properties are valid, but maybe not allowed in current MPM mode, that  check should be done instead in `ValidateForUse()`.
  * `void InitialLoadMechProps(int makeSpecific,int np)` (optional) - this method is called once at beginning (by base class implementation of `VerifyProperties()` in `MaterialBase` calss). For efficiency, use this method to calculate material properties that are independent of the particle state and thus will remain constant throughout the calculation. These properties may be useful in the material's constitutive law calculations. Be sure to call super class `InitialLoadMechProps(makeSpecific,np)` method to allow its calculations.
  * `void InitialLoadTransProps(void)` (optional) - this method is called right after `InitialLoadMechProps()`. For efficiency, use this method to calculate transport properties that are independent of the particle state and thus will remain constant throughout the calculation. Be sure to call super class `InitialLoadTransProps(makeSpecific,np)` method to allow its calculations. `MaterialBase` automatically finds diffusion and conductivity tensors for isotropic material by using material properties `D` (in `diffusionCon`) for diffusion constant and `kCond` (in `kCond`) for thermal conductivity.
  * `void PrintMechanicalProperties(void)` - this method should print all mechanical properties or call super class and print just the new mechanical properties. Use a format compatible with code that will read results file and use style similar to other materials (need not pass on to `MaterialBase` or `Elastic` since they print nothing). This method is called after `VerifyProperties()` and `InitialLoadMechProps()` are done.
  * `void PrintTransportProperties(void)` (optional) - this method should print all transport properties in format compatible with code that will read results file. It should only print them if transport is activated (_i.e._, `if(DiffusionTask::active)` or `if(ConductionTask::active)`). The `MaterialBase` class prints isotropic properties and the `ORTHO` and `TRANSISO1(2)` classes print anisotropic properties. No additional printing is needed if one of these classes handles the task.
  * `virtual void ValidateForUse(int np)` (optional) - this method is called just before the first MPM time step and only for materials used by one or more materials. Throw an exception if this material cannot by used in current MPM mode (type specified in `np` which will be `PLANE_STRAIN_MPM`, `PLANE_STRESS_MPM`, or `THREED_MPM`). If implemented and material accepted, it should pass control to the super class. Basic material properties and usually checked in `VerifyProperties()` instead; this method is for materials that may have valid properties, but may be contingent on other MPM settings.
		
== History Dependent Properties ==

For some materials, the constitutive law will depend on the state of the particle in the form of history-dependent data (_e.g._ cumulative plastic strain for plasticity or strain history for viscoelasticity). Such properties are implemented in a material by using history data. The methods in the material class are as follows:

  * `char *MaterialData(void)` (optional) - this method is called once for each material point using this material at the start of the calculations. It should allocate memory to store history data on the particle, initialize the values, and return a pointer to the structure. It can be as simple as a single variable or a pointer to an array of any number of variables. If a class overrides this method in a super class, the material will need to make sure all history data is correctly allocated and accessible.
  * `double GetHistory(int num,char *ptr)` - this method should extract history variable number `num` from the allocated data pointer in `ptr`. This method is only used when archiving results and `num` will only be 1 through 4 (currently only the first four history variables can be archived). If `num` is out of range for the current material, this method should return zero.

To access values of history variables during constitutive law calculations, you can fetch them from the material point methods `GetHistoryPtr()`, `GetHistoryDble()`, and `SetHistoryDble()`.

= MPM Step Calculations =

The bulk of MPM calculations for a material will be done in the material-dependent code that is called during each MPM time step. Below is a summary of the key methods. These methods should be made as efficient as possible.

== Prepare for Updates ==

These methods are called prior to constitutive law methods to allow update of material properties when those material properties depend on the current state of the particle (_e.g._, properties that depend on temperature, moisture, orientation, or current particle's stress or stain):

  * `virtual void LoadMechanicalProps(MPMBase *,int)` (optional) - this method is called just before the constitutive law on each time step. You can set any parameters for the material that depend on the current state of the particle. Things that never change (_i.e._, properties that are independent of particle state) should be calculated in `InitialLoadMechProps()` instead. Some materials also used in FEA make use of `LoadMechProps()` in this task, but that method is limited to 2D because it only inputs a single rotation about the `z` axis.
  * `virtual void LoadTransportProps(MPMBase *)` (optional) - This method is called when looping over material points to store parameters needed in transport calculations (_i.e._, diffusion and conductivity tensors). It is called prior to the transport task to `AddForces()`. It is only needed for anistropic materials or for materials whose transport properties change depending on particle state. This method should load the required values into `diffusionTensor` and `kCondTensor` variables. It is automatically handled for subclasses of `TRANSISO1(2`) if the only effect is the current orientation. Transport properties that never change (_i.e._, independent of particle state) should be calculated in `InitialLoadTransProps()` instead.
  * `virtual double GetHeatCapacity(MPMBase *)`  (optional) - when conduction is activated, this method is called before calculations that depend on heat capacity C<sub>P</sub>. If C<sub>P</sub> changes with particle state, return current heat capacity using units of J/(g-K). This method can be ignored if C<sub>P</sub> is a constant (note that the `heatCapacity` variable in `MaterialBase` is internally stored in J/(g-K) during calculations, although it is input as J/(kg-K)).
  * `virtual double GetHeatCapacityVol(MPMBase *mptr)`  (optional) - This method has the same function as `GetHeatCapacity()` except applies to constant volume heat capacity C<sub>V</sub>, and the base class variable is `heatCapacityVol`. No core methods depend on C<sub>V</sub> and none call this accessor. A new material, however, may choose to use it.

== Constitutive Law Methods ==

Once the properties are set (from previous section), one of these methods is called to implement the constitutive law. The separate methods for 2D or 3D calculations.

  *  `virtual void MPMConstLaw(MPMBase *,double,double,double,double,double,int)` - This methods applies constitutive law for the material in 2D calculations and updates all needed particle properties. The required updates include stress (should be a specific stress), strain, plastic strain, rotational strain, strain energy, plastic energy, dissipated energy (dissipated needed if want to couple to conduction), and any material history dependent variables defined for the material. To support thermal and solvent expansion, include their effect on the constitutive law. Then input `dvij` are components of velocity gradient times the time step, which gives components of the deformation gradient change.
  * `virtual void MPMConstLaw(MPMBase *,double,double,double,double,double,double,double,double,double,double,int)` - This method is the same as the previous method except it applies to 3D calculations and the extra input variables define the full change in the 3D deformation gradient.

= Traction Law Materials (only for traction law materials) =

There is currently no template code for traction law materials, but the creation process is much easier than creating a new material. Here are some notes on creating traction law materials.

== Create Traction Law Class ==

To get started, create a new traction law class and configure `NairnMPM` to use it as follows:

  * The base class for all traction laws in `TractionLaw.cpp`. It is an abstract class that does not implement any traction law, but it does provide some support for subordinate traction law classes:
    # It reads mode I and mode II cohesive stresses using names `sigmaI` and `sigmaII` and stores then in object variables `stress1` and `stress2`. All tractions lows will need at least one of these stresses.
    # Because `TractionLaw` is a material subclass of `MaterialBase` and many material options are not needed, this traction law base class overrides or blocks any that could cause problems. The new traction law materials therefore need not worry about those details.
  * To create a new traction law, create a new subclass of `TractionLaw` (or of one of its subclasses). The class needs is own unique number that is unique from all other materials and traction laws.
  * Instantiate an instance of the traction law in `AddMaterial()` of `MaterialController.cpp` when `matID` matching the traction law's number occurs.
  * Add the new traction law's number to the list of allowed numbers for the `Material` element in the `NairnMPM.dtd` file.

== Traction Law Initiation ==

Once the new traction law class is created as described in previous section, write all the methods needed to implement it. This section describes initialization methods called before the calculations begin.

  * Constructor - initialize custom variables and then pass control on to parent class (it must get to the main `TractionLaw` constructor).
  * `InputMat(char *xName,int &input)` - if `xName` matches a custom parameter for this law, set `input` to the variable type (_e.g._, `DOUBLE_NUM`) and return pointer to the variable cast as a `char ``*`. Any new parameter names need to be added to the options in the `Material` element in the `NairnMPM.dtd` file.
  * `VerifyProperties(in np)` - This method checks all parameters. If missing or invalid parameters were provided, return an error message (as a string). If all is acceptable, pass control to the parent class.
  * `PrintMechanicalProperties(void)` - Print the traction law properties if format suitable for the output results file. See other tractions laws for standard style. Once this output is printed, this method is a good place to calculate common terms, such as to convert input parameters to more convenient units for use in subsequent calculations or to calculate other properties that remain constant throughout the calculation.
  * `MaterialData(void)` - Many traction laws unload differently then they load, which is interpreted as damage. Implementing such laws typically requires history variables, such as to record the previous maximum crack opening displacement. Use this method to allocate memory for any number of history variables residing on a single crack segment particle. Return pointer to the data, which may by an array of variables.

== Traction Law Implementation ==

These two core methods are the ones that actually implement the traction law and are called often during calculations.

  * `CrackTractionLaw(CrackSegment *cs,double nCod,double tCod,double dx,double dy,double area)` - Calculate normal and tangential tractions for current normal (`nCod`) and shear (`tCod`) crack opening displacements. The results are returned in analysis coordinates as forces in `cs->tract` vector. Typically, this method finds `Tn` and `Tt` and then calculates `cs->tract.x=area``*``(Tn``*``dy - Tt``*``dx)` and `cs->tract.y=area``*``(-Tn``*``dx - Tt``*``dy)` where the required `area`, `dx`, and `dy` are provided input paremeters. <br>Another function of this method is to determine if the traction law has failed (reached critical condition determined by any desired failure criterion). If it has failed, tell the crack segment using `cs->SetMatID(0)`. All traction laws also report the debonding event by calling `ReportDebond()` in the `TractionLaw` class or by their own custom method.
  * `CrackTractionEnergy(CrackSegment *cs,double nCod,double tCod,bool fullEnergy)` - Calculate full energy (if `fullEnergy` is `true`) or released energy (if `fullEnergy` is `false`) for current normal (`nCod`) and shear (`tCod`) crack opening displacements and return the result. This method is needed to find J integal and to archive R curve results during propagation calculations; it is thus needed when propagation is being simulated. The standard approach used in `NairnMPM` to find released energy is to subtract the area under an unloading curve from the current traction back to the origin (_i.e._, to assume elastic unloading in the traction law).<br>Formally (in my opinion), this calculation is not possible unless the loading in monotonic; it must therefore assume monotonic loading has occurred. Further research needs to be aimed at this topic for all use of cohesive laws in numerical modeling. 

== Traction Law Accessors ==

The following traction law accessors should be provided.

  * `MaterialType(void)` - Return character string with the name of the traction law.
  * `MaterialTag(void)` - Return the traction laws unique number

= Fracture Methods =

(This section needs more details)

The methods deal with fracture and are currently handled for all materials in the base class.

  * `virtual MaterialBase *SetFinalPropagate(void)` - hould be enough in default method to set up fracture criterion
  * `virtual Vector ConvertJToK(Vector,Vector,Vector,int)` - Convert J Integral to K or stress intensity factor. Default returns zero.
  * `virtual int CriterionNeeds(void)` - Determines if J and/or K is needed.
  * `virtual int ShouldPropagate(CrackSegment *,Vector &,CrackHeader *,int np)` - Determine if crack chould grow.
  * `virtual bool ControlCrackSpeed(CrackSegment *,double &)` - Adjust crack speed
  * `virtual bool SelectDirection(CrackSegment *,Vector &,CrackHeader *)` - 
  * `virtual void HoopDirection(double,double,Vector *)` - 
  * `void RotateDirection(Vector *,double,double)` - 
  * `virtual double CrackPropagationAngleFromStrainEnergyDensityCriterion(double,double,double)` -  - Used in one fracture criterion
  * `static const char *PreferredDirection(int)` - 